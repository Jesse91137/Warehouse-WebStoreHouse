title: StoreHouseStock_OrderData 操作規格
version: 1.0
last_updated: 2025-11-14
owner: 倉儲團隊
tags: [schema, process, design]
---
StoreHouseStock_OrderData 操作規格
=================================
簡介
----

此文件為 developer-grade 規格，描述 StoreHouseStock_OrderData（以下簡稱 OrderData）的操作邏輯、資料契約、Confirm 交易示意、稽核（InventoryLedger）模型、索引建議、驗收準則與測試策略。文件目標為可直接實作並納入自動化測試。
目的與範圍
----------

定義
----

需求、限制與指引
- CON-001: 交易應儘量短（short-lived tx），避免在 transaction 內做大量 I/O。

- ConfirmedBy, ConfirmedAt
- Version (int)
- Reason (nvarchar)
- CreatedBy (nvarchar)
- Ledger 必須能重建任一時間點的庫存狀態。
- Confirm 需在同一 DB 交易內更新 Inventory 並寫入 InventoryLedger（atomic）。
- 交易內避免呼叫外部同步服務；跨系統一致性以 Saga/補償處理。

責任與邊界
----------

Service:

    - 商業驗證
    - 交易協調（呼叫 Repository）
Repository:

    - 原子性 DB 操作（Version 檢查 / 必要時 SELECT ... FOR UPDATE）
    - 寫入 InventoryLedger 並更新 Inventory

介面與 DTO 範例（C# / JSON）
---------------------------

    public interface IOrderService
    {
        Task<OrderDataDto> GetOrderAsync(string orderId);
        Task<OrderDataDto> UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion);
        Task<ResultDto> ConfirmOrderAsync(string orderId, string userId);
        Task<ResultDto> CancelOrderAsync(string orderId, string userId, string reason);
    }

CreateOrderDto 範例（JSON）

    {
        "OrderId": "WH-0001",
        "OperationType": "OUT",
        "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
        "Reason": "Customer order",
        "CreatedBy": "alice",
        "Version": 1
    }

Confirm 交易偽碼（縮排程式碼）
--------------------------

    BEGIN TRANSACTION;

    -- 讀取訂單狀態與版本
    SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

    -- 檢查並鎖定庫存（必要時）
    SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

    -- 扣減庫存
    UPDATE Inventory
        SET Quantity = Quantity - @Quantity
        WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

    -- 寫入稽核 Ledger
    INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
        VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());
        WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

- 庫存不足：Rollback，回傳 422，不修改 Inventory 或 Ledger。
- Version 衝突：Rollback，回傳 409，呼叫端應重取並重試或人工處理。
- IX_Orders_OrderId (OrderId) UNIQUE
- IX_Orders_Status_CreatedAt (Status, CreatedAt)
-------------------------------

- AC-003: 若庫存不足，Confirm 回滾且 API 回傳 422，不產生 Ledger 或改變 Inventory/Order。
- AC-004: Version 不符時，Confirm 回傳 409 並不修改 Inventory。
測試策略
--------

- 單元測試：Service 層（happy path、validation、insufficient stock、version conflict）。
- 整合測試：Create -> Confirm -> 驗證 Order/Inventory/Ledger 在隔離測試 DB 的一致性。
- 併發測試：模擬多個 concurrent Confirm 呼叫，驗證鎖、回滾與重試策略。

範例與邊界情況
--------------

- 並發 Confirm：同一 Item/Location 多個同時 Confirm 會導致 409 或庫存不足，建議設計重試上限與告警。

下一步建議 artefact
--------------------

- 若您同意，我可以依序建立：

 1) SQL DDL：Orders / Inventory / InventoryLedger（含索引與 FK）。
 2) C# DTO + IOrderService 範例實作（含樂觀鎖處理）。
 3) xUnit integration tests（含並發情境）。

title: StoreHouseStock_OrderData 操作規格
version: 1.0
date_created: 2025-11-14
last_updated: 2025-11-14
owner: 倉儲團隊
tags: [schema, process, design]
---

StoreHouseStock_OrderData 操作規格
=================================

簡介
----

此文件為 developer-grade 規格，描述 StoreHouseStock_OrderData（以下簡稱 OrderData）的操作邏輯、資料契約、Confirm 交易示意、稽核（InventoryLedger）模型、索引建議、驗收準則與測試策略。文件目標為可直接實作並納入自動化測試。

Purpose & Scope
----------------

- Purpose：定義 OrderData 的建立、修改、確認、取消與一致性要求。
 - Scope：資料模型、Service/Repository 介面、Confirm 交易示意、InventoryLedger 設計、索引、驗收準則與測試策略；假設使用關聯式 SQL 資料庫。

Definitions
-----------

- OrderData：倉儲作業單（入/出/調撥/調整）。
- OperationType：IN / OUT / TRANSFER / ADJUST / COUNT。
- Status：Draft / Confirmed / Completed / Cancelled。
 - Version：整數，作為樂觀鎖（optimistic lock）。

Requirements, Constraints & Guidelines
-------------------------------------

- REQ-001: 建立 Order 時，必須回傳唯一 OrderId。
- REQ-002: Confirm 時需在資料庫交易中更新 Inventory 並寫入 InventoryLedger（atomic）。
- REQ-003: 使用 Version 欄位作樂觀鎖；當 Version 不符時回傳 409（VersionConflict）。
 - REQ-004: 當庫存不足時，Confirm 必須回滾並回傳 422（InsufficientStock）。
 - SEC-001: 不在資料庫交易中呼叫外部同步服務；若需跨系統一致性，採 Saga/補償模式。
 - CON-001: 交易應儘量短（short-lived tx），避免在 transaction 內做大量 I/O。

OrderData 欄位建議
------------------

- Id (bigint) — 系統 PK
- OrderId (nvarchar) — 業務單號（唯一）
- OperationType (nvarchar)
- Status (nvarchar)
- SourceLocationId, TargetLocationId (int)
- Items (JSON 或 子表：ItemId, Quantity, Unit)
- Reason (nvarchar)
- CreatedBy, CreatedAt
- ConfirmedBy, ConfirmedAt
 - Version (int)

InventoryLedger（稽核）欄位建議
--------------------------------

- Id (bigint)
- RefOrderId (nvarchar)
- ItemId (bigint)
- LocationId (int)
- Change (decimal)
- BalanceAfter (decimal)
- Reason (nvarchar)
- CreatedBy (nvarchar)
 - CreatedAt (datetime)

Design Principles
-----------------

- Ledger 必須能重建任一時間點的庫存狀態。
- Confirm 需在同一 DB 交易內更新 Inventory 並寫入 InventoryLedger（atomic）。
- 樂觀鎖（Version）為預設策略；針對高衝突情境可使用悲觀鎖（SELECT ... FOR UPDATE）。
 - 跨系統一致性請以 Saga/補償模式處理；交易內避免呼叫外部同步服務。

Service / Repository Responsibilities
------------------------------------

Service:

    - 負責商業驗證
    - 協調交易（呼叫 Repository）並處理錯誤/重試策略

    - 執行原子性 DB 操作（包含 Version 檢查或必要時之 SELECT ... FOR UPDATE）
    - 寫入 InventoryLedger 與更新 Inventory

Service / Repository 介面範例（C#）
-------------------------------

    public interface IOrderService
    {
        Task<string> CreateOrderAsync(CreateOrderDto dto);
        Task<OrderDataDto> GetOrderAsync(string orderId);
        Task<OrderDataDto> UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion);
        Task<ResultDto> ConfirmOrderAsync(string orderId, string userId);
        Task<ResultDto> CancelOrderAsync(string orderId, string userId, string reason);
    }

Create / Update DTO 範例（JSON）
----------------------------

    {
        "OrderId": "WH-0001",
        "OperationType": "OUT",
        "SourceLocationId": 1,
        "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
        "Reason": "Customer order",
        "CreatedBy": "alice",
        "Version": 1
    }

Confirm 交易示意（伪碼，縮排程式碼）
---------------------------------

    BEGIN TRANSACTION;

    -- 讀取 Order 與 Version
    SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

    -- 檢查庫存並鎖定（必要時）
    SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

    -- 扣減庫存
    UPDATE Inventory
        SET Quantity = Quantity - @Quantity
        WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

    -- 寫入稽核 Ledger
    INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
        VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());

    -- 樂觀鎖更新 Order
    UPDATE StoreHouseStock_OrderData
        SET Status = 'Confirmed', ConfirmedBy = @User, ConfirmedAt = GETDATE(), Version = Version + 1
        WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

    COMMIT;

Error Handling
--------------

    - Insufficient stock：Rollback，回傳 422（業務錯誤），不得修改 Inventory 或 Ledger。
    - Version conflict：Rollback，回傳 409（呼叫端應重取並重試或提示使用者）。
    - DB error：Rollback，回傳 500，並在後端記錄細節以便調查。

Indexes & Performance
---------------------

    - IX_Orders_OrderId (OrderId) UNIQUE
    - IX_Orders_Status_CreatedAt (Status, CreatedAt)
    - IX_Inventory_Item_Location (ItemId, LocationId)
    - IX_Ledger_Item_CreatedAt (ItemId, CreatedAt)

Acceptance Criteria
-------------------

    - AC-001: CreateOrder 後可透過 GetOrder 讀回正確資料。
    - AC-002: Confirm 成功時，Inventory 與 InventoryLedger 正確更新。
    - AC-003: 若庫存不足，Confirm 回滾且 API 回傳 422，不產生 Ledger 或改變 Inventory/Order。
    - AC-004: Version 不符時，Confirm 回傳 409 並不修改 Inventory。

Test Strategy
-------------

    - Unit: Service 層（happy path、validation、insufficient stock、version conflict）。
    - Integration: Create -> Confirm -> 驗證 Order/Inventory/Ledger 在測試 DB 一致性。
    - Concurrency: 模擬多個 concurrent Confirm 呼叫，驗證鎖與回滾邏輯。

Examples & Edge Cases
---------------------

    - 並發 Confirm：若同時多個呼叫競爭相同庫存，可發生 VersionConflict 或 InsufficientStock。建議：遇 409 時重試或人工處理。

Next steps / Artefacts
----------------------

以下 artefact 可選（請回覆要建立哪些項目）：

    1) SQL DDL：Orders / Inventory / InventoryLedger（含索引與 FK）。
    2) C# DTO + IOrderService 範例實作（含樂觀鎖處理）。
    3) xUnit integration tests（含並發情境）。

=================================

簡介
----

此文件為 developer-grade 規格，詳述 StoreHouseStock_OrderData（以下簡稱 OrderData）的操作邏輯、資料契約、Confirm 交易示意、稽核 Ledger 設計、索引建議、驗收標準與測試策略。目標為可直接實作並納入 CI 測試。

Purpose & Scope
----------------

- Purpose：定義 OrderData 的建立、修改、確認、取消與一致性要求。
- Scope：資料模型、Service/Repository 介面、Confirm 交易示意、InventoryLedger、索引、驗收與測試策略；假設使用關聯式 SQL 資料庫。

Definitions
-----------

- OrderData：倉儲作業單（入/出/調撥/調整）。
- OperationType：IN / OUT / TRANSFER / ADJUST / COUNT。
- Status：Draft / Confirmed / Completed / Cancelled。
- Version：整數，作為樂觀鎖（optimistic lock）。

OrderData 欄位建議
------------------

- Id (bigint) — 系統 PK
- OrderId (nvarchar) — 業務單號（唯一）
- OperationType (nvarchar)
- Status (nvarchar)
- SourceLocationId, TargetLocationId (int)
- Items (JSON 或 子表：ItemId, Quantity, Unit)
- Reason (nvarchar)
- CreatedBy, CreatedAt
- ConfirmedBy, ConfirmedAt
- Version (int)

InventoryLedger（稽核）欄位建議
--------------------------------

- Id (bigint)
- RefOrderId (nvarchar)
- ItemId (bigint)
- LocationId (int)
- Change (decimal)
- BalanceAfter (decimal)
- Reason (nvarchar)
- CreatedBy (nvarchar)
- CreatedAt (datetime)

設計要點
--------

- Ledger 必須能重建任一時間點的庫存狀態。
- Confirm 需在同一 DB 交易內更新 Inventory 並寫入 InventoryLedger（atomic）。
- 樂觀鎖（Version）為預設策略；針對高衝突情境可使用悲觀鎖（SELECT ... FOR UPDATE）。
- 跨系統一致性請以 Saga/補償模式處理；交易內避免呼叫外部同步服務。

責任分工（簡述）
--------------

Service：負責商業驗證、交易協調與錯誤回應。

Repository：負責原子 DB 操作、Version 驗證、Inventory 與 Ledger 寫入。

Service / Repository 介面範例（C#）
-------------------------------

    public interface IOrderService
    {
        Task<string> CreateOrderAsync(CreateOrderDto dto);
        Task<OrderDataDto> GetOrderAsync(string orderId);
        Task<OrderDataDto> UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion);
        Task<ResultDto> ConfirmOrderAsync(string orderId, string userId);
        Task<ResultDto> CancelOrderAsync(string orderId, string userId, string reason);
    }

Create / Update DTO 範例（JSON）
----------------------------

    {
        "OrderId": "WH-0001",
        "OperationType": "OUT",
        "SourceLocationId": 1,
        "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
        "Reason": "Customer order",
        "CreatedBy": "alice",
        "Version": 1
    }

Confirm 交易示意（伪碼，縮排程式碼）
---------------------------------

    BEGIN TRANSACTION;

    -- 讀取 Order 與 Version
    SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

    -- 檢查庫存並鎖定（必要時）
    SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

    -- 扣減庫存
    UPDATE Inventory
        SET Quantity = Quantity - @Quantity
        WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

    -- 寫入稽核 Ledger
    INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
        VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());

    -- 樂觀鎖更新 Order
    UPDATE StoreHouseStock_OrderData
        SET Status = 'Confirmed', ConfirmedBy = @User, ConfirmedAt = GETDATE(), Version = Version + 1
        WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

    COMMIT;

錯誤處理要點
------------

- 庫存不足：Rollback，回傳 422（業務錯誤），不得修改 Inventory 或 Ledger。
- Version 衝突：Rollback，回傳 409（呼叫端應重取並重試或提示使用者）。
- 其他 DB 錯誤：Rollback，回傳 500，並在後端記錄細節以便調查。

索引建議
-------

- IX_Orders_OrderId (OrderId) UNIQUE
- IX_Orders_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)
- IX_Ledger_Item_CreatedAt (ItemId, CreatedAt)

驗收準則（Acceptance Criteria）
-------------------------------

    - AC-001: CreateOrder 後可透過 GetOrder 讀回建立資料。
    - AC-002: Confirm 成功時，Inventory 與 InventoryLedger 正確更新。
    - AC-003: 若庫存不足，Confirm 回滾且 API 回傳 422。
    - AC-004: Version 不符時，Confirm 回傳 409，且不修改 Inventory。

測試策略
--------

- 單元測試：Service 層（happy path、validation、insufficient stock、version conflict）。
- 整合測試：在隔離測試 DB 執行 Create -> Confirm，驗證 Order/Inventory/Ledger 一致性。
- 併發測試：模擬多個 concurrent Confirm 呼叫，驗證鎖與回滾邏輯。

範例與邊界情況
--------------

- 並發 Confirm：若同時多個呼叫競爭相同庫存，可發生 VersionConflict 或 InsufficientStock。建議：遇 409 時重試或人工處理。

下一步 artefact 建議
--------------------

- 我可以為您建立以下 artefact：

    1) SQL DDL：Orders / Inventory / InventoryLedger（含索引與 FK）。
    2) C# DTO + IOrderService 範例實作（含樂觀鎖處理）。
    3) xUnit integration tests（含並發情境）。

- 請回覆您要我建立哪些項目（可多選）。

=================================

簡介
----

此文件為開發者規格（developer-grade），定義 StoreHouseStock_OrderData（OrderData）的資料契約、Confirm 交易示意、稽核（InventoryLedger）模型、索引建議、驗收準則與測試策略，並以可直接實作為目標。

Purpose & Scope
----------------

- Purpose：定義 OrderData 的建立、修改、確認、取消及一致性要求。
- Scope：資料模型、Service/Repository 介面、Confirm 交易示意、InventoryLedger、索引建議、驗收與測試。

Definitions
-----------

- OrderData：倉儲作業單。
- OperationType：IN / OUT / TRANSFER / ADJUST / COUNT。
- Status：Draft / Confirmed / Completed / Cancelled。
- Version：整數，作為樂觀鎖（optimistic lock）。

Key Fields (OrderData)
---------------------

- Id (bigint)
- OrderId (nvarchar) — 業務單號（唯一）
- OperationType, Status
- SourceLocationId, TargetLocationId (int)
- Items (JSON 或 子表：ItemId, Quantity, Unit)
- Reason, CreatedBy, CreatedAt, ConfirmedBy, ConfirmedAt
- Version (int)

InventoryLedger 建議欄位
-----------------------

- Id, RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt

Design Principles
-----------------

- 在單一 DB 交易內更新 Inventory 並寫入 InventoryLedger（atomic）。
- 樂觀鎖為預設；必要時對 Inventory 使用行級悲觀鎖（SELECT ... FOR UPDATE）。
- 交易應短、避免在 transaction 內呼叫外部同步服務；跨系統請採 Saga/補償。

Service / Repository Responsibilities
------------------------------------

Service:

    - 商業驗證與交易協調

Repository:

    - 原子性 DB 操作、Version 驗證、Inventory 與 Ledger 寫入

Interface Examples (C# signatures)
---------------------------------

    public interface IOrderService
    {
        Task<string> CreateOrderAsync(CreateOrderDto dto);
        Task<OrderDataDto> GetOrderAsync(string orderId);
        Task<OrderDataDto> UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion);
        Task<ResultDto> ConfirmOrderAsync(string orderId, string userId);
        Task<ResultDto> CancelOrderAsync(string orderId, string userId, string reason);
    }

DTO Example (JSON)
------------------

    {
        "OrderId": "WH-0001",
        "OperationType": "OUT",
        "SourceLocationId": 1,
        "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
        "Reason": "Customer order",
        "CreatedBy": "alice",
        "Version": 1
    }

Confirm Transaction (pseudocode)
-------------------------------

    BEGIN TRANSACTION;

    SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

    SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

    UPDATE Inventory
        SET Quantity = Quantity - @Quantity
        WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

    INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
        VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());

    UPDATE StoreHouseStock_OrderData
        SET Status = 'Confirmed', ConfirmedBy = @User, ConfirmedAt = GETDATE(), Version = Version + 1
        WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

    COMMIT;

Error Handling
--------------

- Insufficient stock：Rollback，回傳 422（業務錯誤）。
- Version conflict：Rollback，回傳 409（呼叫端應重試或提示）。
- DB error：Rollback，回傳 500 並記錄。

Indexes & Performance
---------------------

- IX_Orders_OrderId (OrderId) UNIQUE
- IX_Orders_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)
- IX_Ledger_Item_CreatedAt (ItemId, CreatedAt)

Acceptance Criteria
-------------------

    - AC-001: CreateOrder 後可透過 GetOrder 讀回正確資料。
    - AC-002: Confirm 成功時，Inventory 與 InventoryLedger 正確更新。
    - AC-003: 庫存不足時，Confirm 回滾且 API 回傳 422，不產生 Ledger 或修改 Inventory/Order。
    - AC-004: Version 不符時，Confirm 回傳 409 並不修改 Inventory。

Test Strategy
-------------

- Unit: Service 層（happy path、validation、insufficient stock、version conflict）。
- Integration: Create -> Confirm -> 驗證 Order/Inventory/Ledger 在測試 DB 中一致性。
- Concurrency: 模擬多個 concurrent Confirm 呼叫，驗證鎖與錯誤處理。

Next steps
----------

- 我可以為您建立：SQL DDL、C# DTO + IOrderService 範例、或 xUnit integration tests（可多選）。

- 請回覆您要我建立哪些 artefact。
StoreHouseStock_OrderData 操作規格
=================================

簡介
----

此文件為開發者規格，描述 StoreHouseStock_OrderData（以下簡稱 OrderData）的資料契約、關鍵操作（以 Confirm 為重點）、交易示意、稽核（InventoryLedger）模型、索引建議、驗收準則與測試策略。

Purpose & Scope
----------------

- Purpose：定義 OrderData 的建立、修改、確認、取消與完成流程及稽核需求。
- Scope：資料欄位建議、Service/Repository 介面、Confirm 交易示意、稽核結構、索引建議、驗收與測試策略。

Definitions
-----------

- OrderData / StoreHouseStock_OrderData：倉儲作業單。
- OperationType：IN / OUT / TRANSFER / ADJUST / COUNT。
- Status：Draft / Confirmed / Completed / Cancelled。
- Version：整數，作為樂觀鎖（optimistic lock）。

Key Data Fields (OrderData)
---------------------------

- Id (bigint)
- OrderId (nvarchar) — 業務單號（唯一）
- OperationType (nvarchar)
- Status (nvarchar)
- SourceLocationId (int)
- TargetLocationId (int)
- Items (JSON 或 子表，包含 ItemId, Quantity, Unit)
- Reason (nvarchar)
- CreatedBy, CreatedAt
- ConfirmedBy, ConfirmedAt
- Version (int)

InventoryLedger 建議欄位
-----------------------

- Id (bigint)
- RefOrderId (nvarchar)
- ItemId (bigint)
- LocationId (int)
- Change (decimal)
- BalanceAfter (decimal)
- Reason (nvarchar)
- CreatedBy (nvarchar)
- CreatedAt (datetime)

Design Principles
-----------------

- Ledger 必須能重建任一時間點的庫存狀態。
- Confirm 操作在同一 DB 交易內更新 Inventory 並寫入 InventoryLedger（atomic）。
- 樂觀鎖（Version）為預設；必要時可對 Inventory 執行行級悲觀鎖（SELECT ... FOR UPDATE）。
- 交易應短且避免在 transaction 內呼叫外部同步服務；跨系統一致性採 Saga/補償模式。

Service / Repository 責任摘要
------------------------------

Service：

    - 驗證商業規則
    - 協調交易（呼叫 Repository）並處理錯誤/重試

Repository：

    - 執行原子性 DB 操作（包含 Version 檢查或必要時之 SELECT ... FOR UPDATE）
    - 寫入 InventoryLedger 與更新 Inventory

Interface Examples (C# signatures)
---------------------------------

    public interface IOrderService
    {
        Task<string> CreateOrderAsync(CreateOrderDto dto);
        Task<OrderDataDto> GetOrderAsync(string orderId);
        Task<OrderDataDto> UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion);
        Task<ResultDto> ConfirmOrderAsync(string orderId, string userId);
        Task<ResultDto> CancelOrderAsync(string orderId, string userId, string reason);
    }

DTO Examples (JSON)
------------------

    {
        "OrderId": "WH-0001",
        "OperationType": "OUT",
        "SourceLocationId": 1,
        "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
        "Reason": "Customer order",
        "CreatedBy": "alice",
        "Version": 1
    }

Transaction Flow: Confirm (pseudocode)
------------------------------------

    BEGIN TRANSACTION;

    -- 讀取訂單狀態與版本
    SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

    -- 檢查並鎖定庫存（必要時使用 FOR UPDATE）
    SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

    -- 扣減庫存
    UPDATE Inventory
        SET Quantity = Quantity - @Quantity
        WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

    -- 寫入 Ledger
    INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
        VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());

    -- 樂觀鎖更新 Order
    UPDATE StoreHouseStock_OrderData
        SET Status = 'Confirmed', ConfirmedBy = @User, ConfirmedAt = GETDATE(), Version = Version + 1
        WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

    COMMIT;

Error Handling Rules
--------------------

- Insufficient stock：Rollback, return 422（業務錯誤）。
- Version conflict：Rollback, return 409（呼叫端應重新讀取並重試或提示）。
- DB error：Rollback, return 500 並記錄細節。

Indexes & Performance
---------------------

- IX_Orders_OrderId (OrderId) UNIQUE
- IX_Orders_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)
- IX_Ledger_Item_CreatedAt (ItemId, CreatedAt)

Acceptance Criteria
-------------------

    - AC-001: CreateOrder 後可透過 GetOrder 讀回正確資料。
    - AC-002: Confirm 成功時，Inventory 與 InventoryLedger 正確更新。
    - AC-003: 庫存不足時，Confirm 回滾且 API 回傳 422，不產生 Ledger 或改變 Inventory/Order。
    - AC-004: Version 不符時，Confirm 回傳 409 並不修改 Inventory。

Test Strategy
-------------

Unit tests：Service 層（happy path、validation、insufficient stock、version conflict）。

Integration tests：使用隔離測試 DB 執行 Create -> Confirm，驗證 Order/Inventory/Ledger 一致性。

Concurrency tests：模擬多個 concurrent Confirm 呼叫，驗證鎖與錯誤處理。

Next steps / Artefacts
----------------------

可建立的 artefact：

    1) SQL DDL：Orders / Inventory / InventoryLedger（含索引與 FK）。
    2) C# DTO + IOrderService 範例實作（含樂觀鎖處理）。
    3) xUnit integration tests（含並發情境）。

請回覆您要我建立的項目（可多選）。
title: StoreHouseStock_OrderData 操作規格
version: 1.0
date_created: 2025-11-14
last_updated: 2025-11-14
owner: 倉儲團隊
tags: [schema, process, design]
---
StoreHouseStock_OrderData 操作規格
=================================

簡介
----

此文件為開發者級規格，描述 StoreHouseStock_OrderData（以下簡稱 OrderData）的資料契約、關鍵操作流程（以 Confirm 為重點）、交易示意、稽核（InventoryLedger）模型、索引建議、驗收準則與測試策略。文件設計目標為可直接實作並供自動化測試使用。

Purpose & Scope
----------------

- Purpose: 定義倉儲訂單的建立、修改、確認、取消與完成流程，以及一致性與稽核需求。
- Scope: 涵蓋資料欄位建議、Service/Repository 介面、確認流程交易示意、稽核結構、索引建議、驗收準則及測試策略。假設使用關聯式 SQL 資料庫。

Definitions
-----------

- OrderData / StoreHouseStock_OrderData：倉儲訂單資料物件。
- OperationType：IN, OUT, TRANSFER, ADJUST, COUNT。
- Status：Draft, Confirmed, Completed, Cancelled。

Requirements, Constraints & Guidelines
-------------------------------------

- REQ-001: 建立 Order 時，必須回傳唯一 OrderId。
- REQ-002: Confirm 時需在資料庫交易中更新 Inventory 並寫入 InventoryLedger（atomic）。
StoreHouseStock_OrderData 操作規格
=================================

簡介
----

此文件為開發者級規格，描述 StoreHouseStock_OrderData（以下簡稱 OrderData）的資料契約、關鍵操作流程（以 Confirm 為重點）、交易示意、稽核（InventoryLedger）模型、索引建議、驗收準則與測試策略。文件設計目標為可直接實作並供自動化測試使用。

Purpose & Scope
----------------

- Purpose: 定義倉儲訂單的建立、修改、確認、取消與完成流程，以及一致性與稽核需求。
- Scope: 涵蓋資料欄位建議、Service/Repository 介面、確認流程交易示意、稽核結構、索引建議、驗收準則及測試策略。假設使用關聯式 SQL 資料庫。

Definitions
-----------

- OrderData / StoreHouseStock_OrderData：倉儲訂單資料物件。
- OperationType：IN, OUT, TRANSFER, ADJUST, COUNT。
- Status：Draft, Confirmed, Completed, Cancelled。
- Version：整數，作為樂觀鎖（optimistic lock）。

Requirements, Constraints & Guidelines
-------------------------------------

- REQ-001: 建立 Order 時，必須回傳唯一 OrderId。
- REQ-002: Confirm 時需在資料庫交易中更新 Inventory 並寫入 InventoryLedger（atomic）。
- REQ-003: 使用 Version 欄位作樂觀鎖；當 Version 不符時回傳 409（VersionConflict）。
- REQ-004: 當庫存不足時，Confirm 必須回滾並回傳 422（InsufficientStock）。
- SEC-001: 不在資料庫交易中呼叫外部同步服務；若需跨系統一致性，採 Saga/補償模式。
- CON-001: 交易應儘量短（short-lived tx），避免在 transaction 內做大量 I/O。
- GUD-001: 對高頻寫入熱點（Inventory）避免過多索引；對查詢熱點建立覆蓋索引。

Interfaces & Data Contracts
---------------------------

以下為建議介面與 DTO 範例（C# 與 JSON 範例，供參考）：

    public interface IOrderService
    {
        Task<string> CreateOrderAsync(CreateOrderDto dto);
        Task<OrderDataDto> GetOrderAsync(string orderId);
        Task<OrderDataDto> UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion);
        Task<ResultDto> ConfirmOrderAsync(string orderId, string userId);
        Task<ResultDto> CancelOrderAsync(string orderId, string userId, string reason);
    }

CreateOrderDto 範例（JSON）：

    {
        "OrderId": "optional-string",
        "OperationType": "OUT",
        "SourceLocationId": 1,
        "TargetLocationId": null,
        "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
        "Reason": "Customer order",
        "CreatedBy": "alice",
        "Version": 1
    }

UpdateOrderDto 範例（JSON）：

    {
        "Items": [ { "ItemId": 1001, "Quantity": 3 } ],
        "Reason": "Adjusted quantity"
    }

OrderData schema（重要欄位）：

- Id (bigint)
- OrderId (nvarchar) -- 業務單號（唯一）
- OperationType (nvarchar)
- Status (nvarchar)
- SourceLocationId (int)
- TargetLocationId (int)
- Items (JSON / 子表)
- Reason (nvarchar)
- CreatedBy, CreatedAt
- ConfirmedBy, ConfirmedAt
- Version (int)

InventoryLedger 建議欄位：

- Id (bigint)
- RefOrderId (nvarchar)
- ItemId (bigint)
- LocationId (int)
- Change (decimal)
- BalanceAfter (decimal)
- Reason (nvarchar)
- CreatedBy (nvarchar)
- CreatedAt (datetime)

Acceptance Criteria

    - AC-001: CreateOrder 後可透過 GetOrder 成功讀回建立資料。
    - AC-002: Confirm 成功時，Inventory 正確扣減且 InventoryLedger 寫入對應記錄。
    - AC-003: 若庫存不足，Confirm 回滾且不修改 Inventory/Order/Ledger，API 回傳 422。
    - AC-004: Version 不符時，Confirm 回傳 409 並不修改 Inventory。

Test Automation Strategy

    - Test Levels: Unit, Integration, End-to-End。
    - Frameworks: xUnit（.NET）、FluentAssertions、Moq（用於 Repository mock）。
    - Test Data Management: 使用獨立測試 DB（容器化或專用 schema），每個測試 case 在前置建立資料與後置清理。
    - CI/CD Integration: 在 GitHub Actions pipeline 中，針對 Pull Request 執行 Unit + Integration 測試；對整合測試使用 DB container。
    - Coverage Requirements: 重要 Service 路徑（Create/Confirm/Cancel）至少覆蓋 80% 單元測試。

Rationale & Context

    使用樂觀鎖（Version）作為預設策略，因為大多數業務情境寫入衝突少且可重試；在高併發或短時間內多個 confirm 競爭相同庫存時，可在 repository 層對 Inventory 執行行級悲觀鎖（SELECT ... FOR UPDATE）來避免超賣。

Dependencies & External Integrations

External Systems

    - EXT-001: ERP / WMS 外部系統 - 提供訂單來源資料（若有），應以非同步方式接收並以 Saga 處理跨系統一致性。

Third-Party Services

    - SVC-001: 短訊 / Email service - 用於通知（非交易性），應在交易外執行。

Infrastructure Dependencies

    - INF-001: 關聯式資料庫（例如：SQL Server / PostgreSQL），需支援行級鎖與事務。

Examples & Edge Cases

示例：Confirm 成功（單一 Item）

    BEGIN TRANSACTION;

    SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

    SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

    UPDATE Inventory
        SET Quantity = Quantity - @Quantity
        WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

    INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
        VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());

    UPDATE StoreHouseStock_OrderData
        SET Status = 'Confirmed', ConfirmedBy = @User, ConfirmedAt = GETDATE(), Version = Version + 1
        WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

    COMMIT;

Edge case：並發 Confirm

    - 若兩個 concurrent 呼叫同時欲 confirm 相同 Order 或同一庫存，可能導致 VersionConflict 或 Inventory 可用量不足。建議的處理：當 VersionConflict 回傳 409 時，呼叫端重新讀取資料並重試，或提示手動處理。

Validation Criteria

    - 所有 AC 項目應有對應自動化測試覆蓋。
    - 在 CI 上執行整合測試：Create -> Confirm -> 驗證 Inventory / Ledger / Order 狀態一致。

Related Specifications / Further Reading

    - spec-inventory-ledger.md （建議另存，描述 InventoryLedger 詳細 DDL 與查詢）
    - 公司內部 API 標準（連結）

此文件為開發者級規格，包含欄位建議、Service/Repository 介面、Confirm 交易示意、稽核（InventoryLedger）模型、索引建議、驗收標準與測試策略。請在閱讀後回覆要我建立的 artefact（例如：SQL DDL / C# DTO + IOrderService / xUnit tests）。

Purpose & Scope
---------------

- Purpose: 定義倉儲訂單（OrderData）之建立、修改、確認、取消與完成流程與稽核需求。
- Scope: 資料欄位建議、Service/Repository 介面、確認交易示意、稽核結構、索引與測試策略（假設關聯式 SQL DB）。

Definitions
-----------

- OrderData / StoreHouseStock_OrderData：倉儲作業單。
- OperationType：IN / OUT / TRANSFER / ADJUST / COUNT。
- Status：Draft / Confirmed / Completed / Cancelled。
- Version：整數，作為樂觀鎖（optimistic lock）。

Key Data Fields (OrderData)
--------------------------

- Id (bigint)
- OrderId (nvarchar) — 業務單號（唯一）
- OperationType (nvarchar)
- Status (nvarchar)
- SourceLocationId (int)
- TargetLocationId (int)
- Items (JSON 或 子表，包含 ItemId, Quantity, Unit)
- Reason (nvarchar)
- CreatedBy, CreatedAt
- ConfirmedBy, ConfirmedAt
- Version (int)

InventoryLedger (稽核) 建議欄位
------------------------------

- Id (bigint)
- RefOrderId (nvarchar)
- ItemId (bigint)
- LocationId (int)
- Change (decimal)
- BalanceAfter (decimal)
- Reason (nvarchar)
- CreatedBy (nvarchar)
- CreatedAt (datetime)

Design Principles
-----------------

- Ledger 必須能重建任一時間點的庫存狀態。
- Confirm 操作在同一 DB 交易內要同時更新 Inventory 並寫入 InventoryLedger（atomic）。
- 樂觀鎖（Version）為預設；高衝突熱點可在 repository 層對 Inventory 使用行級悲觀鎖（SELECT ... FOR UPDATE）。
- 交易應短且避免在 transaction 內呼叫外部同步服務；跨系統一致性請採 Saga/補償。

Service / Repository 職責（摘要）
---------------------------------

Service:

    - 驗證商業規則
    - 協調交易（呼叫 Repository），處理錯誤 mapping 與重試策略

Repository:

    - 執行原子性 DB 操作（包含 Version 檢查或必要時之 SELECT ... FOR UPDATE）
    - 寫入 InventoryLedger 與更新 Inventory

Interface Examples (C# signatures)
---------------------------------

    public interface IOrderService
    {
        Task<string> CreateOrderAsync(CreateOrderDto dto);
        Task<OrderDataDto> GetOrderAsync(string orderId);
        Task<OrderDataDto> UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion);
        Task<ResultDto> ConfirmOrderAsync(string orderId, string userId);
        Task<ResultDto> CancelOrderAsync(string orderId, string userId, string reason);
    }

DTO Examples (JSON style, indented)
----------------------------------

    {
        "OrderId": "WH-0001",
        "OperationType": "OUT",
        "SourceLocationId": 1,
        "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
        "Reason": "Customer order",
        "CreatedBy": "alice",
        "Version": 1
    }

Transaction Flow: Confirm (pseudocode)
------------------------------------

    BEGIN TRANSACTION;

    -- 讀取訂單狀態與版本
    SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

    -- 檢查並鎖定庫存（必要時使用 FOR UPDATE）
    SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

    -- 扣減庫存
    UPDATE Inventory
        SET Quantity = Quantity - @Quantity
        WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

    -- 寫入 Ledger
    INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
        VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());

    -- 樂觀鎖更新 Order
    UPDATE StoreHouseStock_OrderData
        SET Status = 'Confirmed', ConfirmedBy = @User, ConfirmedAt = GETDATE(), Version = Version + 1
        WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

    COMMIT;

Error Handling Rules
--------------------

- Insufficient stock: Rollback, return 422 (business error). Do not modify Inventory or Ledger.
- Version conflict: Rollback, return 409 (client should re-fetch and retry or surface to user).
- DB error: Rollback, return 500 and log details for investigation.

Indexes & Performance Hints
---------------------------

- IX_Orders_OrderId (OrderId) UNIQUE
- IX_Orders_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)
- IX_Ledger_Item_CreatedAt (ItemId, CreatedAt)

Acceptance Criteria
-------------------

    - AC-001: CreateOrder 後可透過 GetOrder 讀回正確資料。
    - AC-002: Confirm 成功時，Inventory 與 InventoryLedger 正確更新。
    - AC-003: 庫存不足時，Confirm 回滾且 API 回傳 422，不產生 Ledger 或改變 Inventory/Order。
    - AC-004: Version 不符時，Confirm 回傳 409 並不修改 Inventory。

Test Strategy
-------------

Unit tests:

    - Service 層單元測試（happy path、validation、insufficient stock、version conflict）

Integration tests:

    - 使用隔離的測試 DB 執行 Create -> Confirm，驗證 Order/Inventory/Ledger 一致性

Concurrency tests:

    - 模擬多個 concurrent Confirm 呼叫，驗證鎖與錯誤處理策略

Next steps
----------

- 我可以為您建立以下 artefact：

    1. SQL DDL：Orders / Inventory / InventoryLedger（含索引與 FK）
    2. C# DTO 與 IOrderService 範例實作（含樂觀鎖處理）
    3. xUnit integration tests（含並發情境）

請告訴我您要我建立哪一項（可多選）。


- SVC-001: 短訊 / Email service - 用於通知（非交易性），應在交易外執行。

Infrastructure Dependencies

- INF-001: 關聯式資料庫（例如：SQL Server / PostgreSQL），需支援行級鎖與事務。

Examples & Edge Cases
---------------------

示例：Confirm 成功（單一 Item）

    BEGIN TRANSACTION;

    SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

    SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

    UPDATE Inventory
        SET Quantity = Quantity - @Quantity
        WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

    INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
        VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());

    UPDATE StoreHouseStock_OrderData
        SET Status = 'Confirmed', ConfirmedBy = @User, ConfirmedAt = GETDATE(), Version = Version + 1
        WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

    COMMIT;

Edge case：並發 Confirm

- 若兩個 concurrent 呼叫同時欲 confirm 相同 Order 或同一庫存，可能導致 VersionConflict 或 Inventory 可用量不足。建議的處理：當 VersionConflict 回傳 409 時，呼叫端重新讀取資料並重試，或提示手動處理。

Validation Criteria
-------------------

- 所有 AC 項目應有對應自動化測試覆蓋。
- 在 CI 上執行整合測試：Create -> Confirm -> 驗證 Inventory / Ledger / Order 狀態一致。

Related Specifications / Further Reading
--------------------------------------

- spec-inventory-ledger.md （建議另存，描述 InventoryLedger 詳細 DDL 與查詢）
- 公司內部 API 標準（連結）

--------------------------------

請回覆要我建立的 artefact（例如：SQL DDL / C# DTO+IOrderService / xUnit tests）。
StoreHouseStock_OrderData 操作規格
=================================

此文件為 StoreHouseStock_OrderData（簡稱 OrderData）的開發者規格。
目標：提供一份清晰、可直接實作的操作說明，包含建立／修改／確認／取消等流程、交易示意、稽核設計、索引建議與驗收標準。

目的與範圍
StoreHouseStock_OrderData 操作規格
=================================

目的
----
此文件定義 StoreHouseStock_OrderData（以下簡稱 OrderData）的操作邏輯，供開發與測試使用。內容包含建立/修改/確認/取消流程、交易示意、稽核資料模型、索引建議與驗收標準。

定義
- Status：Draft / Confirmed / Completed / Cancelled。

- CancelledBy, CancelledAt
- Version (int) — 樂觀鎖
Service / Repository 介面（範例）
--------------------------------
- UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion) -> OrderData
- ConfirmOrderAsync(string orderId, string userId) -> Result
- CancelOrderAsync(string orderId, string userId, string reason) -> Result
- GetOrderAsync(string orderId) -> OrderData
- QueryOrdersAsync(QueryParams p) -> PagedResult

StoreHouseStock_OrderData 是倉庫系統中代表入/出/調撥等作業的資料結構。本文件提供可直接實作的操作規格，包含資料契約、確認交易示意、稽核（InventoryLedger）設計、索引建議與驗收標準。

核心定義
--------

---
title: StoreHouseStock_OrderData 操作規格
version: 1.0
date_created: 2025-11-14
last_updated: 2025-11-14
owner: 倉儲團隊
tags: [schema, process, design]
---

StoreHouseStock_OrderData 操作規格
=================================

簡介
----

此文件為開發者級規格，描述 StoreHouseStock_OrderData（以下簡稱 OrderData）的資料契約、關鍵操作流程（以 Confirm 為重點）、交易示意、稽核（InventoryLedger）模型、索引與效能建議、驗收準則與測試策略。本文件設計目標為可直接實作並供自動化測試使用。

1. Purpose & Scope
-------------------

- Purpose: 定義倉儲訂單的建立、修改、確認、取消與完成流程，以及一致性與稽核需求。
- Scope: 涵蓋資料欄位建議、Service/Repository 介面、確認流程交易示意、稽核結構、索引建議、驗收準則及測試策略。假設使用關聯式 SQL 資料庫。

2. Definitions
--------------

- OrderData / StoreHouseStock_OrderData：倉儲訂單資料物件。
- OperationType：IN, OUT, TRANSFER, ADJUST, COUNT。
- Status：Draft, Confirmed, Completed, Cancelled。
- Version：整數，作為樂觀鎖（optimistic lock）。

3. Requirements, Constraints & Guidelines
-----------------------------------------

- REQ-001: 建立 Order 時，必須回傳唯一 OrderId。
- REQ-002: Confirm 時需在資料庫交易中更新 Inventory 並寫入 InventoryLedger（atomic）。
- REQ-003: 使用 Version 欄位作樂觀鎖；當 Version 不符時回傳 409（VersionConflict）。
- REQ-004: 當庫存不足時，Confirm 必須回滾並回傳 422（InsufficientStock）。
- SEC-001: 不在資料庫交易中呼叫外部同步服務；若需跨系統一致性，採 Saga/補償模式。
- CON-001: 交易應儘量短（short-lived tx），避免在 transaction 內做大量 I/O。
- GUD-001: 對高頻寫入熱點（Inventory）避免過多索引；對查詢熱點建立覆蓋索引。

4. Interfaces & Data Contracts
-----------------------------

以下為建議介面與 DTO 範例（C# 與 JSON 範例，供參考）：

    public interface IOrderService
    {
        Task<string> CreateOrderAsync(CreateOrderDto dto);
        Task<OrderDataDto> GetOrderAsync(string orderId);
        Task<OrderDataDto> UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion);
        Task<ResultDto> ConfirmOrderAsync(string orderId, string userId);
        Task<ResultDto> CancelOrderAsync(string orderId, string userId, string reason);
    }

CreateOrderDto 範例（JSON）：

    {
        "OrderId": "optional-string",
        "OperationType": "OUT",
        "SourceLocationId": 1,
        "TargetLocationId": null,
        "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
        "Reason": "Customer order",
        "CreatedBy": "alice",
        "Version": 1
    }

UpdateOrderDto 範例（JSON）：

    {
        "Items": [ { "ItemId": 1001, "Quantity": 3 } ],
        "Reason": "Adjusted quantity"
    }

建議 OrderData schema（重要欄位）：

- Id (bigint)
- OrderId (nvarchar) -- 業務單號（唯一）
- OperationType (nvarchar)
- Status (nvarchar)
- SourceLocationId (int)
- TargetLocationId (int)
- Items (JSON / 子表)
- Reason (nvarchar)
- CreatedBy, CreatedAt
- ConfirmedBy, ConfirmedAt
- Version (int)

InventoryLedger 建議欄位：

- Id (bigint)
- RefOrderId (nvarchar)
- ItemId (bigint)
- LocationId (int)
- Change (decimal)
- BalanceAfter (decimal)
- Reason (nvarchar)
- CreatedBy (nvarchar)
- CreatedAt (datetime)

5. Acceptance Criteria
----------------------

- AC-001: CreateOrder 後可透過 GetOrder 成功讀回建立資料。
- AC-002: Confirm 成功時，Inventory 正確扣減且 InventoryLedger 寫入對應記錄。
- AC-003: 若庫存不足，Confirm 回滾且不修改 Inventory/Order/Ledger，API 回傳 422。
- AC-004: Version 不符時，Confirm 回傳 409 並不修改 Inventory。

6. Test Automation Strategy
---------------------------

- Test Levels: Unit, Integration, End-to-End。
- Frameworks: xUnit（.NET）、FluentAssertions、Moq（用於 Repository mock）。
- Test Data Management: 使用獨立測試 DB（容器化或專用 schema），每個測試 case 在前置建立資料與後置清理。
- CI/CD Integration: 在 GitHub Actions pipeline 中，針對 Pull Request 執行 Unit + Integration 測試；對整合測試使用 DB container。 
- Coverage Requirements: 重要 Service 路徑（Create/Confirm/Cancel）至少覆蓋 80% 單元測試。

7. Rationale & Context
----------------------

使用樂觀鎖（Version）作為預設策略，因為大多數業務情境寫入衝突少且可重試；在高併發或短時間內多個 confirm 競爭相同庫存時，可在 repository 層對 Inventory 執行行級悲觀鎖（SELECT ... FOR UPDATE）來避免超賣。

8. Dependencies & External Integrations
---------------------------------------

External Systems

- EXT-001: ERP / WMS 外部系統 - 提供訂單來源資料（若有），應以非同步方式接收並以 Saga 處理跨系統一致性。

Third-Party Services

- SVC-001: 短訊 / Email service - 用於通知（非交易性），應在交易外執行。

Infrastructure Dependencies

- INF-001: 關聯式資料庫（例如：SQL Server / PostgreSQL），需支援行級鎖與事務。

9. Examples & Edge Cases
------------------------

示例：Confirm 成功（單一 Item）

    BEGIN TRANSACTION;

    SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

    SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

    UPDATE Inventory
        SET Quantity = Quantity - @Quantity
        WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

    INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
        VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());

    UPDATE StoreHouseStock_OrderData
        SET Status = 'Confirmed', ConfirmedBy = @User, ConfirmedAt = GETDATE(), Version = Version + 1
        WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

    COMMIT;

Edge case：並發 Confirm

- 若兩個 concurrent 呼叫同時欲 confirm 相同 Order 或同一庫存，可能導致 VersionConflict 或 Inventory 可用量不足。建議的處理：當 VersionConflict 回傳 409 時，呼叫端重新讀取資料並重試，或提示手動處理。

10. Validation Criteria
-----------------------

- 所有 AC 項目應有對應自動化測試覆蓋。
- 在 CI 上執行整合測試：Create -> Confirm -> 驗證 Inventory / Ledger / Order 狀態一致。

11. Related Specifications / Further Reading
------------------------------------------

- spec-inventory-ledger.md （建議另存，描述 InventoryLedger 詳細 DDL 與查詢）
- 公司內部 API 標準（連結）

--------------------------------

--------------------------------

**DISCLAIMER**: 本文件由自動化工具協助草擬，請由專案團隊審核後再進行實作。



----------------

- 庫存不足：Rollback 並回傳 422（業務錯誤），不得修改 Inventory 或 Ledger。
- Version 衝突：Rollback 並回傳 409，呼叫端應重取並重試或提示使用者。
- 其他 DB 錯誤：Rollback 並回傳 500，詳細錯誤寫入稽核日誌。

交易示意（縮排式程式碼）
-------------------------

    BEGIN TRANSACTION;

    SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

    SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

    UPDATE Inventory
        SET Quantity = Quantity - @Quantity
        WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

    INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
        VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());

    UPDATE StoreHouseStock_OrderData
        SET Status = 'Confirmed', ConfirmedBy = @User, ConfirmedAt = GETDATE(), Version = Version + 1
        WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

    COMMIT;

資料契約（DTO 範例）
---------------------

CreateOrderDto 範例

    {
        "OrderId": "optional-string",
        "OperationType": "OUT",
        "SourceLocationId": 1,
        "TargetLocationId": null,
        "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
        "Reason": "Customer order",
        "CreatedBy": "alice",
        "Version": 1
    }

UpdateOrderDto 範例

    {
        "Items": [ { "ItemId": 1001, "Quantity": 3 } ],
        "Reason": "Adjusted quantity"
    }

索引建議
---------

- Orders: IX_Orders_OrderId (OrderId) UNIQUE
- Orders: IX_Orders_Status_CreatedAt (Status, CreatedAt)
StoreHouseStock_OrderData 操作規格
=================================

簡介
----

此文件為開發者規格，描述 StoreHouseStock_OrderData（以下簡稱 OrderData）的資料契約、關鍵操作流程（以 Confirm 為重點）、交易示意、稽核（InventoryLedger）模型、索引建議、驗收準則與測試策略。

Purpose & Scope
----------------

- Purpose：定義 OrderData 的生命週期與一致性要求。

- Scope：資料模型、Service/Repository 介面、Confirm 交易示意、稽核結構、索引、驗收與測試。

Definitions
-----------

- OrderData：倉儲作業單。

- OperationType：IN / OUT / TRANSFER / ADJUST / COUNT。

- Status：Draft / Confirmed / Completed / Cancelled。

- Version：整數，作為樂觀鎖（optimistic lock）。

Key Fields (OrderData)
---------------------

- Id (bigint)

- OrderId (nvarchar) — 業務單號（唯一）

- OperationType, Status

- SourceLocationId, TargetLocationId (int)

- Items (JSON 或 子表：ItemId, Quantity, Unit)

- Reason, CreatedBy, CreatedAt, ConfirmedBy, ConfirmedAt

- Version (int)

InventoryLedger 建議欄位
-----------------------

- Id, RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt

Design Principles
-----------------

- Ledger 必須能重建任一時間點的庫存狀態。

- Confirm 操作在同一 DB 交易內更新 Inventory 並寫入 InventoryLedger（atomic）。

- 樂觀鎖（Version）為預設；必要時可對 Inventory 執行行級悲觀鎖（SELECT ... FOR UPDATE）。

- 交易應短且避免在 transaction 內呼叫外部同步服務；跨系統一致性採 Saga/補償模式。

Service / Repository (責任)
---------------------------

Service：

    - 商業驗證與交易協調

Repository：

    - 原子性 DB 操作、Version 驗證、Inventory 與 Ledger 寫入

Interface (C# signatures)
-------------------------

    public interface IOrderService
    {
        Task<string> CreateOrderAsync(CreateOrderDto dto);
        Task<OrderDataDto> GetOrderAsync(string orderId);
        Task<OrderDataDto> UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion);
        Task<ResultDto> ConfirmOrderAsync(string orderId, string userId);
        Task<ResultDto> CancelOrderAsync(string orderId, string userId, string reason);
    }

DTO Example (JSON)
------------------

    {
        "OrderId": "WH-0001",
        "OperationType": "OUT",
        "SourceLocationId": 1,
        "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
        "Reason": "Customer order",
        "CreatedBy": "alice",
        "Version": 1
    }

Confirm Transaction (pseudocode)
-------------------------------

    BEGIN TRANSACTION;

    -- 讀取訂單狀態與版本
    SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

    -- 鎖定並檢查庫存（必要時使用 FOR UPDATE）
    SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

    -- 扣減庫存
    UPDATE Inventory
        SET Quantity = Quantity - @Quantity
        WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

    -- 寫入 Ledger
    INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
        VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());

    -- 樂觀鎖更新 Order
    UPDATE StoreHouseStock_OrderData
        SET Status = 'Confirmed', ConfirmedBy = @User, ConfirmedAt = GETDATE(), Version = Version + 1
        WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

    COMMIT;

Error Handling
--------------

- 庫存不足：Rollback，回傳 422（業務錯誤）。

- Version 衝突：Rollback，回傳 409（呼叫端可重試或提示）。

- 其他 DB 錯誤：Rollback，回傳 500 並記錄。

Indexes
-------

- IX_Orders_OrderId (OrderId) UNIQUE

- IX_Orders_Status_CreatedAt (Status, CreatedAt)

- IX_Inventory_Item_Location (ItemId, LocationId)

- IX_Ledger_Item_CreatedAt (ItemId, CreatedAt)

Acceptance Criteria
-------------------

    - AC-001: CreateOrder 後可透過 GetOrder 讀回正確資料。

    - AC-002: Confirm 成功時，Inventory 與 InventoryLedger 正確更新。

    - AC-003: 庫存不足時，Confirm 回滾且 API 回傳 422，不產生 Ledger 或修改 Inventory/Order。

    - AC-004: Version 不符時，Confirm 回傳 409 並不修改 Inventory。

Test Strategy
-------------

- Unit: Service 層（happy path、validation、insufficient stock、version conflict）。

- Integration: Create -> Confirm -> 驗證 Order/Inventory/Ledger 在測試 DB 中一致性。

- Concurrency: 模擬多個 concurrent Confirm 呼叫，驗證鎖與錯誤處理。

Next steps
----------

- 我可以為您建立：SQL DDL、C# DTO + IOrderService 範例、或 xUnit integration tests（可多選）。

- 請回覆您要我建立哪些 artefact。

- Reason (string)
- CreatedBy (string)
- CreatedAt (datetime)

Ledger 必須能重建任一時間點的庫存變動序列以供稽核與對帳。

## 7 索引建議

- IX_Order_OrderId (OrderId) UNIQUE
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 8 驗收標準（Acceptance Criteria）

- AC-001: CreateOrder 後可透過 GetOrder 讀回正確資料。
- AC-002: Confirm 成功時，Inventory 與 InventoryLedger 正確更新。
- AC-003: 庫存不足時，Confirm 回滾並回傳 422，且不修改 Inventory/Order/Ledger。
- AC-004: Version 不符時，回傳 409，且不修改 Inventory。
- AC-005: Confirm 操作皆寫入 Ledger 以供稽核。

## 9 測試策略（概要）

- 單元測試：Service 層（happy path、InsufficientStock、VersionConflict、validation）。
- 整合測試：在測試 DB 上執行 Create -> Confirm，驗證 Inventory / Ledger / Order 的一致性。
- 並發測試：模擬 concurrent Confirm 呼叫，驗證鎖策略與錯誤處理。

## 10 建議後續 artefact

- SQL DDL：Orders、Inventory、InventoryLedger。
- C# DTO + IOrderService 範例。
- xUnit integration tests（含並發測試）。

請回覆要我建立的 artefact（例如：SQL DDL / C# DTO+IOrderService / xUnit tests）。



> 建議：維護 InventoryLedger（RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt）。

## 4 Service / Repository 介面

- CreateOrderAsync(CreateOrderDto) -> OrderId
- UpdateOrderAsync(orderId, UpdateOrderDto, expectedVersion) -> OrderData
- ConfirmOrderAsync(orderId, userId) -> Result
- CancelOrderAsync(orderId, userId, reason) -> Result
- GetOrderAsync(orderId) -> OrderData

### DTO 範例

```json
{
    "OrderId": "WH-0001",
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "Reason": "Customer order",
    "CreatedBy": "alice"
}
```

## 5 Confirm（交易示意）

步驟：

1. 讀取 Order（Status = Draft）並取得 Version。
2. 檢查來源位置庫存（可使用 SELECT ... FOR UPDATE）。
3. 扣減 Inventory，寫入 InventoryLedger。
4. 更新 Order 為 Confirmed（Version++，樂觀鎖）。
5. Commit；如有錯誤則 Rollback。

```sql
BEGIN TRANSACTION;

SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

-- 檢查狀態與庫存可用性，執行更新與 ledger 寫入

COMMIT;
```

## 6 稽核 / Ledger

- InventoryLedger 建議欄位：RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt

## 7 索引建議

- IX_Order_OrderId (OrderId) UNIQUE
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 8 驗收標準

- AC-001: 成功建立 Order，能透過 GetOrder 讀回。
- AC-002: Confirm 成功會正確更新 Inventory 與 Ledger。
- AC-003: 當庫存不足時，Confirm 需回滾並回傳 422。
- AC-004: Update 發生版本衝突時回傳 409。

---

下一步我可以：產生 SQL DDL、C# DTO 與 interface 範例，或撰寫 xUnit 整合測試樣板。請告訴我您要哪一項。
 # StoreHouseStock_OrderData 操作規格

Hi 豬豬 🐽🐽🐷，這份文件為 StoreHouseStock_OrderData（簡稱 OrderData）的開發者規格。內容包含欄位建議、Service/Repository 介面、Confirm 交易示意、稽核 ledger、索引、驗收標準與測試策略。

## 1 目的與範圍

- 目的：定義倉儲訂單的建立、修改、確認、取消與完成流程，以及一致性與稽核需求。
- 範圍：資料模型、Service/Repository 介面、交易示意、驗收標準與測試策略。

## 2 名詞與定義

- OrderData / StoreHouseStock_OrderData：倉儲訂單資料物件。
- OperationType：IN, OUT, TRANSFER, ADJUST, COUNT。
- Status：Draft, Confirmed, Completed, Cancelled, Rejected。
- OrderId：業務單號（唯一識別）。

## 3 建議資料欄位（範例 schema）

- Id (bigint) — 系統主鍵
- OrderId (nvarchar) — 業務單號（唯一）
- OperationType (nvarchar)
- Status (nvarchar)
- SourceLocationId (int)
- TargetLocationId (int)
- Items (array of { ItemId, Quantity, Unit })
- Reason (nvarchar)
- CreatedBy, CreatedAt
- ConfirmedBy, ConfirmedAt
- CompletedAt
- CancelledBy, CancelledAt
- Version (int) — 樂觀鎖

> 建議維護 InventoryLedger：RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt。

## 4 Service / Repository 介面（範例）

- CreateOrderAsync(CreateOrderDto dto) -> OrderId
- UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion) -> OrderData
- ConfirmOrderAsync(string orderId, string userId) -> Result
- CancelOrderAsync(string orderId, string userId, string reason) -> Result
- GetOrderAsync(string orderId) -> OrderData
- QueryOrdersAsync(QueryParams p) -> PagedResult

### 範例 DTO（CreateOrderDto）

```json
{
    "OrderId": "WH-0001",
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "Reason": "Customer order",
    "CreatedBy": "alice"
}
```

## 5 Confirm（關鍵交易示意）

步驟摘要：

1. 讀取 Order（狀態為 Draft）並讀取 Version。
2. 檢查來源位置庫存（可使用 SELECT ... FOR UPDATE 或其他鎖定策略）。
3. 扣減 Inventory、寫入 InventoryLedger。
4. 以樂觀鎖更新 Order 為 Confirmed（Version++）。
5. Commit；如失敗則 Rollback 並回傳錯誤。

### 示意 SQL（請依實際 DB 調整）

```sql
BEGIN TRANSACTION;

SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN
    ROLLBACK;
    RAISERROR('Order not in Draft or not found', 16, 1);
    RETURN;
END

-- 檢查庫存
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN
  ROLLBACK;
  RAISERROR('Insufficient stock', 16, 1);
  RETURN;
END

-- 扣庫與 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, RefOrderId, Change, CreatedAt, CreatedBy)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE(), @user);

-- 更新 Order
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
  ROLLBACK;
  RAISERROR('Version conflict', 16, 1);
  RETURN;
END

COMMIT;
```

設計要點：

- 交易儘量短、只包必要步驟以降低鎖持有時間。
- 跨系統採 Saga / 補償交易。

## 6 索引建議

- IX_Order_OrderId (OrderId) — 唯一索引
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 7 驗收標準（Acceptance Criteria）

- AC-001: 可建立 Order 並能透過 GetOrder 讀回。
- AC-002: Confirm 成功時 Inventory 與 Ledger 正確更新。
- AC-003: Confirm 庫存不足時整筆回滾並回傳 422。
- AC-004: Update 發生版本衝突時回傳 409。
- AC-005: Cancel 操作留下稽核紀錄。

## 8 錯誤處理對應

- 400 BadRequest — 輸入驗證失敗
- 404 NotFound — Order / Item / Location 不存在
- 409 Conflict — 版本衝突或 OrderId 重複
- 422 UnprocessableEntity — 庫存不足或業務驗證失敗
- 500 InternalServerError — 系統例外

錯誤回應建議欄位： ErrorCode, Message, Details

## 9 測試策略

- 單元測試：Service 邏輯（mock repository）
- 整合測試：使用測試 DB 執行完整流程，驗證 Inventory / Ledger
- 併發測試：模擬多重 Confirm，測試樂觀鎖或悲觀鎖行為
- E2E：從 API 驗證整套流程與稽核日誌

測試範例資料：ItemA qty=100, LocationA

---

如需我產生 SQL DDL、C# DTO 或測試樣板，我可以接著建立這些 artefact。

- UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion) -> OrderData
- ConfirmOrderAsync(string orderId, string userId) -> Result
- CancelOrderAsync(string orderId, string userId, string reason) -> Result
- GetOrderAsync(string orderId) -> OrderData
- QueryOrdersAsync(QueryParams p) -> PagedResult

DTO 範例（CreateOrderDto）：

```json
{
  "OrderId": "string (optional, system can generate)",
  "OperationType": "OUT",
  "SourceLocationId": 1,
# StoreHouseStock_OrderData 操作規格

本文為開發者等級的規格文件，描述 StoreHouseStock_OrderData（以下簡稱 OrderData）的操作邏輯、資料契約、交易示意、稽核模型、索引建議、驗收標準與測試策略。文件需能直接供開發、Code Review 與測試使用，並符合專案 Markdown lint 規範（無硬 tab、單一 H1、code fence 有語言標註等）。

## 1. 目的與範圍

本規格涵蓋以下功能：建立（Create）、查詢（Get/Query）、修改（Update）、確認（Confirm）、取消（Cancel）與相關的 Inventory 更新流程。目標受眾為實作 Service/Repository 的後端工程師與測試工程師。

## 2. 定義與核心欄位

- OrderData：倉庫作業單（出庫、入庫、調撥、調整）。
- Item：庫存項目（ItemId）。
- Location：儲位或倉別（LocationId）。
- OperationType：IN / OUT / TRANSFER / ADJUST / COUNT。
- Status：Draft / Confirmed / Completed / Cancelled。

建議核心欄位（概要）：

- Id (bigint)
- OrderId (string)
- OperationType (string)
- Status (string)
- SourceLocationId (int)
- TargetLocationId (int)
- Items (array of { ItemId, Quantity, Unit })
- Reason (string)
- CreatedBy, CreatedAt
- ConfirmedBy, ConfirmedAt
- CompletedAt
- CancelledBy, CancelledAt
- Version (int)  // 樂觀鎖

## 3. 稽核模型：InventoryLedger

InventoryLedger 為必備稽核表，用以重建任一時間點之庫存狀態。建議欄位：

- Id (bigint)
- RefOrderId (string)
- ItemId (int)
- LocationId (int)
- Change (decimal)  // 正為入(+)，負為出(-)
- BalanceAfter (decimal)
- Reason (string)
- CreatedBy (string)
- CreatedAt (datetime)

需求：Ledger 必須包含 RefOrderId 與操作者資訊，且 Insert 動作應與 Inventory 更新在同一交易內完成。

## 4. Service / Repository 介面（概要）

Service 層負責商業邏輯與交易協調；Repository 層負責資料存取、Version 檢查與必要時的悲觀鎖支援。

範例 C# 介面（摘要）：

```csharp
public interface IOrderService
{
        Task<string> CreateOrderAsync(CreateOrderDto dto);
        Task<OrderData> GetOrderAsync(string orderId);
        Task<OrderData> UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion);
        Task<Result> ConfirmOrderAsync(string orderId, string userId);
        Task<Result> CancelOrderAsync(string orderId, string userId, string reason);
}
```

Repository 職責要點：

- 提供 atomic read/write
- 在使用樂觀鎖時，Update/Confirm 必須以 WHERE Version = @ExpectedVersion
- 在高併發熱點提供 SELECT ... FOR UPDATE 的悲觀鎖選項

## 5. Confirm（確認）操作：流程與錯誤處理

流程摘要（必須是原子交易）：

1. 讀取 Order，驗證 Status == 'Draft'，讀取 Version。
2. 開啟資料庫交易（短範圍）。
3. 對每一筆 Item 檢查 Inventory 可用量；視情況使用悲觀鎖（SELECT ... FOR UPDATE）或使用樂觀鎖後續比對 Version。
4. 若庫存足夠，更新 Inventory（Quantity = Quantity - @Quantity），並 INSERT InventoryLedger（Change = -@Quantity，BalanceAfter = 新餘額）。
5. 更新 Order 為 'Confirmed' 並將 Version++（使用樂觀鎖 WHERE Version = @ExpectedVersion，或在悲觀鎖下直接更新）。
6. Commit；若任何步驟失敗則 Rollback，並回傳明確錯誤碼（例如 InsufficientStock、VersionConflict、ValidationError）。

錯誤處理原則：

- 庫存不足：回滾並回傳 422/BusinessError，且不得對 Inventory 或 Ledger 做任何變更。
- Version 衝突：回滾並回傳 409/VersionConflict，鼓勵呼叫端重新取得最新資料並重試。
- 其他 DB 錯誤：回滾並回傳 500/ServerError，記錄詳細例外以便追查。

### 交易示意（T-SQL pseudocode）

```sql
BEGIN TRANSACTION;

-- 讀取 Order 與 Version
SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

-- 針對每個 Item 鎖定 Inventory（悲觀鎖範例）
SELECT Quantity FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

-- 檢查可用量，若不足則 ROLLBACK

-- 更新 Inventory
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

-- 寫入 Ledger
INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, @BalanceAfter, @Reason, @User, GETDATE());

-- 樂觀鎖更新 Order
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @User, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @ExpectedVersion;

COMMIT;
```

註：實作時應避免在交易內呼叫耗時外部服務；必要情況使用 Saga／補償流程。

## 6. 資料契約（DTO 範例）

CreateOrderDto 範例（JSON）：

```json
{
    "OrderId": "optional-string",
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "Reason": "Customer order",
    "CreatedBy": "alice",
    "Version": 1
}
```

UpdateOrderDto 範例（JSON）：

```json
{
    "Items": [ { "ItemId": 1001, "Quantity": 3 } ],
    "Reason": "Adjusted quantity"
}
```

## 7. 索引與效能建議

- Orders：IX_Orders_OrderId (OrderId) UNIQUE
- Orders：IX_Orders_Status_CreatedAt (Status, CreatedAt)
- Inventory：IX_Inventory_Item_Location (ItemId, LocationId)
- InventoryLedger：IX_Ledger_Item_CreatedAt (ItemId, CreatedAt)

設計原則：以常用查詢路徑為導向建立索引；在高頻寫入表上謹慎增加索引以降低寫入成本。

## 8. 驗收標準（Acceptance Criteria）

- AC-001: 建立 Order 後可透過 GetOrder API 讀回正確資料。
- AC-002: Confirm 成功時，Inventory 依據 Items 正確扣減且 InventoryLedger 有對應紀錄。
- AC-003: 若庫存不足，Confirm 應回滾且資料表不應被修改，API 回傳 422。
- AC-004: 當 Version 衝突時，Confirm 應回傳 409 並不修改 Inventory。

## 9. 測試策略

- 單元測試：針對 Service 層的商業邏輯編寫（包含 happy path、Validation、庫存不足、Version 衝突）。
- 整合測試：在測試 DB 環境執行 Create -> Confirm，驗證 Order / Inventory / InventoryLedger 的一致性。
- 併發測試：模擬多個 concurrent Confirm 呼叫，驗證悲觀鎖或樂觀鎖的行為與重試策略。

測試要點：

- 使用測試 DB 的事務隔離以避免測試互相干擾。
- 對於併發測試，紀錄成功數、衝突數、失敗數，以確保系統在預期負載下的正確性與可觀察性。

## 10. 後續交付（選配）

- 提供 SQL DDL：Orders、Inventory、InventoryLedger（含索引與 FK、約束）。
- 提供 C# DTO 與 IOrderService 範例實作（含樂觀鎖處理與重試範例）。
- 提供 xUnit integration tests（包含並發情境與驗證腳本）。

---

**DISCLAIMER**: 本文件由 GitHub Copilot 協助產生，請在 merge 前由專案工程師審核內容與細節。


Hi 豬豬 🐽🐽🐷，本文件為 StoreHouseStock_OrderData（以下簡稱 OrderData）的開發者規格，目標是提供清晰的欄位建議、Service/Repository 介面、確認交易（Confirm）示意、稽核 (ledger) 設計、索引建議、驗收標準與測試策略。檔案已移除硬 tab 並採用 ATX 標題樣式。

## 1 目的與範圍

- 目的：定義倉儲訂單（出入庫、調撥、盤點調整等）的建立、修改、確認、取消與完成流程，以及一致性與稽核需求。
- 範圍：資料模型、Service/Repository 介面、交易示意、驗收標準與測試策略。

## 2 名詞與定義

- OrderData / StoreHouseStock_OrderData：倉儲訂單資料物件。
- OperationType：IN, OUT, TRANSFER, ADJUST, COUNT。
- Status：Draft, Confirmed, Completed, Cancelled, Rejected。
- OrderId：業務單號（唯一識別）。

## 3 建議資料欄位（範例 schema）

- Id (bigint) — 系統主鍵
- OrderId (nvarchar) — 業務單號（唯一）
- OperationType (nvarchar)
- Status (nvarchar)
- SourceLocationId (int)
- TargetLocationId (int)
- ItemId (int)
- Quantity (decimal)
- Unit (nvarchar)
- Reason (nvarchar)
- CreatedBy, CreatedAt
- ConfirmedBy, ConfirmedAt
- CompletedAt
- CancelledBy, CancelledAt
- Version (int) — 樂觀鎖

> 建議維護 InventoryLedger（RefOrderId、Change、Reason、CreatedBy、CreatedAt）以做變動稽核。

## 4 Service / Repository 介面（範例）

- CreateOrderAsync(CreateOrderDto dto) -> OrderId
- UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion) -> OrderData
- ConfirmOrderAsync(string orderId, string userId) -> Result
- CancelOrderAsync(string orderId, string userId, string reason) -> Result
- GetOrderAsync(string orderId) -> OrderData
- QueryOrdersAsync(QueryParams p) -> PagedResult

DTO 範例（CreateOrderDto）：

```json
{
    "OrderId": "string (optional, system can generate)",
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "Reason": "string",
    "CreatedBy": "alice"
}
```

## 5 Confirm：關鍵交易流程

主要步驟：

1. 讀取 Order（狀態需為 Draft）並讀取 Version。
2. 針對每個 item 檢查來源位置可用庫存（可採 SELECT ... FOR UPDATE 或其他鎖定策略）。
3. 扣庫並寫入 InventoryLedger。
4. 更新 Order 為 Confirmed，Version++。
5. Commit；若失敗則 Rollback 並回傳對應錯誤碼。

示意 SQL（示範用途，請依實際 DB 風格調整）：

```sql
BEGIN TRANSACTION;

-- 讀取 Order 與版本
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN
        ROLLBACK;
        RAISERROR('Order not in Draft or not found', 16, 1);
        RETURN;
END

-- 檢查庫存
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE; -- 若 DB 支援

IF (AvailableQty < @Quantity)
BEGIN
        ROLLBACK;
        RAISERROR('Insufficient stock', 16, 1);
        RETURN;
END

-- 扣庫並寫 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, RefOrderId, Change, CreatedAt, CreatedBy)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE(), @user);

-- 更新 Order（樂觀鎖）
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
        ROLLBACK;
        RAISERROR('Version conflict', 16, 1);
        RETURN;
END

COMMIT;
```

設計備註：

- 儘量在 DB 層使用短交易以降低鎖持有時間。
- 跨系統採 Saga / 補償交易。

## 6 索引建議

- IX_Order_OrderId (OrderId) — 唯一索引
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 7 稽核與 Ledger 規範

- InventoryLedger 建議欄位：Id, ItemId, LocationId, RefOrderId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt
- Ledger 每筆需包含 RefOrderId 與操作者以利追溯
- AuditLog 建議包括：Entity, EntityId, Action, UserId, Timestamp, BeforeSummary, AfterSummary

## 8 驗收標準

- AC-001: 建立 Order 並能透過 GetOrder 讀回
- AC-002: Confirm 成功時 Inventory 與 Ledger 正確更新
- AC-003: Confirm 庫存不足時回滾且回傳 422
- AC-004: Update 版本衝突回傳 409
- AC-005: Cancel 已 Confirm 訂單能正確補償或拒絕，並留下稽核紀錄

## 9 錯誤處理與 HTTP 映射

- 400 BadRequest — 輸入驗證失敗
- 404 NotFound — Order / Item / Location 不存在
- 409 Conflict — 版本衝突或 OrderId 重複
- 422 UnprocessableEntity — 庫存不足或業務驗證失敗
- 500 InternalServerError — 系統例外

錯誤回應應包含： ErrorCode, Message, Details (optional)

## 10 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create / Confirm / Cancel，驗證 Inventory / Ledger 一致性
- 併發測試：模擬多重 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 層驗證整套流程並檢查稽核日誌

測試資料建議：ItemA (qty 100), LocationA, LocationB

## 11 邊界情況與建議

- 多品項訂單中若一品項不足：建議整筆失敗（原子性）；如允許部分成功需明確設計 partial-result 與稽核
- 跨分片或多 DB：採 Saga / 補償流程，並實作去重與重試
- 批次匯入請走批次流程避免即時鎖爭用

## 12 建議後續工作

1. 依此規格產生 SQL CREATE TABLE / Index DDL 與 migration script
2. 產生 C# DTO 與 Service/Repository 介面樣板
3. 撰寫 xUnit / Integration test 範例

---

已完成：本檔為單一 H1、無重複段落、且不含硬 tab 的 canonical 規格檔。如需我再產生 SQL DDL、C# DTO 或測試樣板，請告訴我。
- IX_Order_OrderId (OrderId) — 唯一索引
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 7 稽核與 ledger 規範

- InventoryLedger 建議欄位：Id, ItemId, LocationId, RefOrderId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt
- Ledger 每筆需包含 RefOrderId 與操作者以利追溯
- AuditLog 建議包括：Entity, EntityId, Action, UserId, Timestamp, BeforeSummary, AfterSummary

## 8 驗收標準

- AC-001: 建立 Order 並能透過 GetOrder 讀回
- AC-002: Confirm 成功時 Inventory 與 Ledger 正確更新
- AC-003: Confirm 庫存不足時回滾且回傳 422
- AC-004: Update 版本衝突回傳 409
- AC-005: Cancel 已 Confirm 訂單能正確補償或拒絕，並留下稽核紀錄

## 9 錯誤處理與 HTTP 映射

- 400 BadRequest — 輸入驗證失敗
- 404 NotFound — Order / Item / Location 不存在
- 409 Conflict — 版本衝突或 OrderId 重複
- 422 UnprocessableEntity — 庫存不足或業務驗證失敗
- 500 InternalServerError — 系統例外

錯誤回應應包含： ErrorCode, Message, Details (optional)

## 10 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create / Confirm / Cancel，驗證 Inventory / Ledger 一致性
- 併發測試：模擬多重 Confirm，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 層驗證整套流程並檢查稽核日誌

測試資料建議：ItemA (qty 100), LocationA, LocationB

## 11 邊界情況與建議

- 多品項訂單中若一品項不足：建議整筆失敗（原子性）；如允許部分成功需明確設計 partial result 與稽核
- 跨分片或多 DB：採 Saga / 補償流程，並實作去重與重試
- 批次匯入請走批次流程避免即時鎖爭用

## 12 建議後續工作

1. 依此規格產生 SQL CREATE TABLE / Index DDL 與 migration script
2. 產生 C# DTO 與 Service/Repository 介面樣板
3. 撰寫 xUnit / Integration test 範例

---

已完成：本檔現為單一 front-matter、單一 H1、無硬 tab 的 canonical 規格檔。

下一步請選擇要我產生的 artefact：SQL DDL、C# DTO 與 interface、或測試樣板。

-- 讀取 Order 與版本
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN
  ROLLBACK;
  RAISERROR('Order not in Draft or not found', 16, 1);
  RETURN;
END

-- 針對每個 item 檢查庫存（示意）
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE; -- 若 DB 支援

IF (AvailableQty < @Quantity)
BEGIN
  ROLLBACK;
  RAISERROR('Insufficient stock', 16, 1);
  RETURN;
END

-- 扣庫並寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt, CreatedBy)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE(), @user);

-- 更新 Order（樂觀鎖）
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
  ROLLBACK;
  RAISERROR('Version conflict', 16, 1);
  RETURN;
END

COMMIT;
```

設計備註：

- 儘量在 DB 層使用短交易（short transactions）以減少鎖的持有時間。
- 若跨多個資料分片或外部系統，採 Saga / 補償交易模式。

## 6. 索引建議

- IX_Order_OrderId (OrderId) — 唯一索引。
- IX_Order_Status_CreatedAt (Status, CreatedAt) — 常用查詢。
- IX_Inventory_Item_Location (ItemId, LocationId) — 庫存檢查熱點。

## 7. 稽核與 Ledger 規範

- InventoryLedger 欄位建議：Id, ItemId, LocationId, RefOrderId, Change (decimal, +/−), BalanceAfter (optional), Reason, CreatedBy, CreatedAt。
- Ledger 必須可追溯：每次庫存變動需寫入 ledger，並包含 RefOrderId 與操作使用者。
- 稽核日誌（AuditLog）至少記錄：Entity, EntityId, Action, UserId, Timestamp, BeforeSummary, AfterSummary。

## 8. 驗收標準（Acceptance Criteria）

- AC-001: 建立 Order 並能透過 GetOrder 讀回（資料欄位正確）。
- AC-002: Confirm 成功時，Inventory 與 InventoryLedger 正確更新（數量與 ledger 條目一致）。
- AC-003: Confirm 發生庫存不足時，整筆交易回滾且 API 回傳 422。
- AC-004: Update 發生版本衝突時（Version 不符）回傳 409，資料不被修改。
- AC-005: Cancel 已 Confirm 訂單時，能夠依業務規則產生補償（回補庫存）或拒絕取消，且所有操作可被稽核追蹤。

## 9. 錯誤處理建議與 HTTP 映射

- 400 BadRequest — 輸入驗證失敗。
- 404 NotFound — Order / Item / Location 找不到。
- 409 Conflict — 版本衝突或重複的 OrderId。
- 422 UnprocessableEntity — 庫存不足或業務驗證失敗。
- 500 InternalServerError — 未預期錯誤。

錯誤回應應包含：ErrorCode, Message, Details (optional)。

## 10. 測試策略

- 單元測試：
  - 驗證 DTO 驗證規則、Service 內邏輯（使用 Mock repository）。
- 整合測試：
  - 在測試 DB 上執行 Create / Confirm / Cancel，驗證 Inventory / Ledger 的一致性與原子性。
- 併發測試：
  - 模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為。
- E2E：
  - 從 API 層驗證整套流程並檢查稽核日誌與 ledger 條目。

建議測試資料：ItemA (qty 100), LocationA, LocationB。

## 11. 邊界情況與建議

- 多品項訂單中若某一品項庫存不足：建議整筆 Confirm 失敗（原子性），若業務允許部分成功則必須有清楚的 partial-result 與稽核記錄。
- 跨分片或跨 DB：採 Saga / 補償流程，並設計去重（idempotency）與重試的機制。
- 批次匯入：走批次流程減少即時鎖爭用。

## 12. 建議後續工作（可選／非破壞性）

1. 依此規格產生：
   - SQL CREATE TABLE / Index DDL（提供 migration script）
   - C# DTO 類別與 Service/Repository 介面樣板
   - Integration tests (xUnit / MSTest) 範例
2. 若需要，我可以把本檔拆成更細的 spec（例如 `spec-storehouse-orderdata.md` 與 `spec-storehouse-ledger.md`）。

---

完成：我已將 `StoreHouseStock_OrderData` 的操作規格寫入 `spec/資料查詢.md`（單一 front-matter、單一 H1、無硬 tab）。

下個建議步驟：是否要我依據此規格再產生：

- SQL CREATE TABLE 與 Index DDL
- C# DTO / Service / Repository 介面與簡單實作範例
- xUnit 整合測試樣板

請選擇一項我來接著建立（或告訴我其他優先項目）。
---
title: StoreHouseStock_OrderData 操作規格
version: 1.0
 此檔為經過格式化的開發者規格（單一 H1、ATX 標題、fenced code blocks 已標註語言、無硬 tab）。內容為 StoreHouseStock_OrderData 的關鍵操作說明與驗收準則。
owner: WebStoreHouse Team
 目的：定義 OrderData（倉儲訂單）的建立、修改、確認、取消與完成流程，並說明交易一致性與稽核需求。
 範圍：資料契約、服務介面、Confirm 交易示意、InventoryLedger 稽核、索引建議、驗收標準與測試策略。

 OrderData：倉儲訂單資料（出入庫、調撥、盤點）。
 OperationType：IN / OUT / TRANSFER / ADJUST / COUNT。
 Status：Draft / Confirmed / Completed / Cancelled / Rejected。

 Id (bigint)
 OrderId (string) — 業務單號（唯一）
 OperationType, Status
 SourceLocationId, TargetLocationId
 Items (array of { ItemId, Quantity, Unit })
 Reason, CreatedBy, CreatedAt, ConfirmedBy, ConfirmedAt
 Version (int) — 樂觀鎖

 CreateOrderAsync(CreateOrderDto) -> OrderId
 UpdateOrderAsync(orderId, UpdateOrderDto, expectedVersion) -> OrderData
 ConfirmOrderAsync(orderId, userId) -> Result
 CancelOrderAsync(orderId, userId, reason) -> Result
 GetOrderAsync(orderId) -> OrderData
## 2. 重要欄位（摘要）
 關鍵步驟：
 1. 讀取 Order（狀態為 Draft）並取得 Version。
 2. 檢查每項 Item 的可用庫存；必要時在 Inventory 上鎖定該列（SELECT ... FOR UPDATE）。
 3. 更新 Inventory，並寫入 InventoryLedger（包含 BalanceAfter）。
 4. 使用樂觀鎖更新 Order（Version++ 並 Status='Confirmed'）。
 5. Commit；如任一步失敗則 Rollback 並回傳明確錯誤（InsufficientStock / VersionConflict）。
- Items (array of { ItemId, Quantity, Unit })
 Id (bigint)
 RefOrderId (string)
 ItemId (bigint)
 LocationId (int)
 Change (decimal)
 BalanceAfter (decimal)
 Reason (string)
 CreatedBy (string)
 CreatedAt (datetime)
- ConfirmOrderAsync(string orderId, string userId) -> Result
 IX_Order_OrderId (OrderId) UNIQUE
 IX_Order_Status_CreatedAt (Status, CreatedAt)
 IX_Inventory_Item_Location (ItemId, LocationId)
## 4. DTO 範例
 AC-001: CreateOrder 後可透過 GetOrder 讀回正確資料。
 AC-002: Confirm 成功時，Inventory 與 InventoryLedger 正確更新。
 AC-003: 庫存不足時，Confirm 回滾並回傳 422，且不修改 Inventory/Order/Ledger。
 AC-004: Version 不符時，回傳 409，且不修改 Inventory。
 AC-005: Confirm 操作皆寫入 Ledger 以供稽核。
    "SourceLocationId": 1,
 單元測試：Service 層（happy path、InsufficientStock、VersionConflict、validation）。
 整合測試：在測試 DB 上執行 Create -> Confirm，驗證 Inventory / Ledger / Order 的一致性。
 並發測試：模擬 concurrent Confirm 呼叫，驗證鎖策略與錯誤處理。
}
 SQL DDL：Orders、Inventory、InventoryLedger。
 C# DTO + IOrderService 範例。
 xUnit integration tests（含並發測試）。

Confirm 必須在交易中同時完成：驗證 Order、調整 Inventory 並寫入 InventoryLedger、更新 Order 與 Version。

步驟：

1. 讀取 Order（Status = 'Draft'）並取得 Version。
2. 對每個 Item 檢查來源位置庫存；必要時使用 SELECT ... FOR UPDATE 鎖定。
3. 扣減 Inventory，為每項變更寫入 InventoryLedger（包括 BalanceAfter）。
4. 使用樂觀鎖更新 Order（WHERE OrderId=@orderId AND Version=@expectedVersion），設定 Status='Confirmed' 並 Version=Version+1。
5. Commit；如任何步驟失敗則 Rollback 並回傳特定錯誤（InsufficientStock、VersionConflict）。

示意 SQL（參考）：

```sql
BEGIN TRANSACTION;

-- 4) INSERT INTO InventoryLedger(...)
-- 5) UPDATE StoreHouseStock_OrderData SET Status='Confirmed', Version=Version+1 WHERE OrderId=@orderId AND Version=@expectedVersion

COMMIT;
```

## 6. 稽核 / 索引（摘要）

- InventoryLedger: RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt
- 建議索引：IX_Order_OrderId (UNIQUE), IX_Order_Status_CreatedAt, IX_Inventory_Item_Location

## 7. 驗收標準（摘要）

- AC-001: 成功建立 Order 並可讀回。
- AC-002: Confirm 成功會更新 Inventory 並新增 InventoryLedger 條目。
- AC-003: 庫存不足時，Confirm 回滾並回傳 422。
- AC-004: 版本不符時回傳 409（樂觀鎖）。

## 8. 測試策略（概要）

- 單元測試：Service 層邏輯（建立 / 確認 / 取消）。
- 整合測試：實際 DB 交易，驗證 Commit / Rollback 與 Ledger。
- 並發測試：模擬版本衝突與補償情境。

---

如要，我可以接著產生：SQL DDL、C# DTO 與 Service interface，以及 xUnit 測試樣板。

-- 讀取 Order
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

-- 檢查庫存（示意）
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN
    ROLLBACK;
    RAISERROR('Insufficient stock', 16, 1);
    RETURN;
END

-- 扣庫並寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order（樂觀鎖）
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
    ROLLBACK;
    RAISERROR('Version conflict', 16, 1);
    RETURN;
END

COMMIT;
```

### 建議索引

- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 驗收標準（精簡）

- AC-001: 建立並讀回 Order。
- AC-002: Confirm 成功時庫存與 ledger 正確更新。
- AC-003: Confirm 失敗（庫存不足）時回滾且回傳 422。
- AC-004: Update 發生版本衝突時回傳 409。

## 測試建議

- Unit：Service 內邏輯（mock repository）。
- Integration：測試 DB 上執行 Create / Confirm / Cancel，驗證 Inventory / Ledger。
- Concurrency：模擬多重並發 Confirm，驗證樂觀鎖或悲觀鎖行為。

---

如需我將欄位擴充為正式 schema（包含 SQL CREATE TABLE）、或產生 DTO / 測試樣板，我可以接著產生。
---
title: StoreHouseStock_OrderData 操作規格
version: 1.0
date_created: 2025-11-13
owner: WebStoreHouse Team
tags: [spec, storehouse, orderdata]
---

# StoreHouseStock_OrderData 操作規格

Hi 豬豬 🐽🐽🐷，這是一個精簡且 lint-friendly 的版本：

## 摘要

- 定義倉儲訂單（OrderData）欄位、Service 介面、交易流程與驗收標準

## 目標

- 提供開發者能直接實作的契約與範例：DTO、SQL 交易示意、稽核與測試策略

## 資料模型（欄位範例）

- Id (bigint)
- OrderId (nvarchar) - 唯一
- OperationType (nvarchar) - IN/OUT/TRANSFER/ADJUST/COUNT
- Status (nvarchar) - Draft/Confirmed/Completed/Cancelled/Rejected
- SourceLocationId (int)
- TargetLocationId (int)
- ItemId (int)
- Quantity (decimal)
- Unit (nvarchar)
- Reason (nvarchar)
- CreatedBy, CreatedAt
- ConfirmedBy, ConfirmedAt
- CompletedAt
- CancelledBy, CancelledAt
- Version (int) - 樂觀鎖

> 註：以現有 DB 設計為主，建議加入 InventoryLedger 以做變動稽核

## Service / Repository 主要介面

- CreateOrderAsync(CreateOrderDto dto) -> OrderId
- UpdateOrderAsync(orderId, dto, expectedVersion) -> OrderData
- ConfirmOrderAsync(orderId, userId) -> Result
- CancelOrderAsync(orderId, userId, reason) -> Result
- GetOrderAsync(orderId) -> OrderData
- QueryOrdersAsync(params) -> PagedResult

## Create DTO 範例

```json
{

    "OperationType": "OUT",
    "SourceLocationId": 1,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

## Confirm（關鍵交易）示意

1. 讀取 Order，檢查狀態為 Draft，並取得 Version
2. 對每個 item 檢查來源位置可用庫存（SELECT ... FOR UPDATE）
3. 扣庫（UPDATE Inventory）並寫入 InventoryLedger
4. 更新 Order 狀態為 Confirmed，Version++（樂觀鎖或在 WHERE 加上 Version 驗證）
5. Commit 或在失敗時 Rollback

示意 SQL：

```sql
BEGIN TRANSACTION;

-- 檢查與鎖定
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

-- 檢查庫存
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

-- 扣庫與 ledger
UPDATE Inventory SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

COMMIT;
```

## 驗收準則（簡要）

- AC-001: 建立並讀回 Order
- AC-002: Confirm 成功時庫存與 ledger 正確更新
- AC-003: Confirm 失敗（庫存不足）時回滾且回傳 422
- AC-004: Update 發生版本衝突時回傳 409

## 測試建議

- Unit: Service 邏輯 (mock repository)
- Integration: 使用測試 DB 驗證原子性（Create -> Confirm -> 檢查 Inventory / Ledger）
- Concurrency: 並發 Confirm 測試（樂觀鎖/悲觀鎖行為）

---

如需更完整的欄位定義、ER 圖或產生 DTO / 測試樣板，我可以接著產生。


- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準（Acceptance Criteria）

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create / Confirm / Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS / ERP 同步，建議使用事件（Event）或 webhook，並設計重試 / 去重機制

## 14 範例 JSON

Create 請求範例：

```json
{
  "OperationType": "OUT",
  "SourceLocationId": 1,
  "TargetLocationId": null,
  "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
  "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量批次匯入應走批次流程以避免即時鎖爭用

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

本文為 StoreHouseStock_OrderData 的操作規格。如需我拆成專用檔或產生 DTO / 測試範例，請告訴我下一步
---
title: StoreHouseStock_OrderData 操作規格
version: 1.0
date_created: 2025-11-13
owner: WebStoreHouse Team
tags: [spec, storehouse, orderdata]
---

# StoreHouseStock_OrderData 操作規格

Hi 豬豬 🐽🐽🐷，這份文件定義 StoreHouseStock_OrderData（以下稱 OrderData）的資料契約與操作邏輯，供開發、測試與系統整合使用。

## 摘要

- 描述 OrderData 的資料欄位與契約
- 定義 Create / Update / Confirm / Cancel / Complete 的服務契約與交易行為
- 提供 Confirm 的 SQL 範例、JSON 範例、驗收標準與測試策略

## 1 目的與範圍

- 目的：定義倉儲訂單的建立、修改、確認與取消行為，以及一致性保證
- 範圍：資料模型、Service / Repository 介面、交易流程與測試策略

## 2 名詞定義

- OrderData / StoreHouseStock_OrderData：倉儲操作記錄
- OperationType：IN, OUT, TRANSFER, ADJUST, COUNT
- Status：Draft, Confirmed, Completed, Cancelled, Rejected
- OrderId：業務單號（唯一識別）

## 3 建議資料欄位（範例）

- Id (bigint) - 系統主鍵
- OrderId (nvarchar) - 業務單號（唯一）
- OperationType (nvarchar) - 操作類型
- Status (nvarchar) - 訂單狀態
- SourceLocationId (int) - 來源儲位 / 倉別
- TargetLocationId (int) - 目標儲位 / 倉別
- ItemId (int) - 品項識別
- Quantity (decimal) - 數量
- Unit (nvarchar) - 單位（pcs / kg）
- Reason (nvarchar) - 備註或原因
- CreatedBy (nvarchar), CreatedAt (datetime)
- ConfirmedBy (nvarchar), ConfirmedAt (datetime)
- CompletedAt (datetime)
- CancelledBy (nvarchar), CancelledAt (datetime)
- Version (int) - 樂觀鎖版本號

> 註：若系統已有對應表，請以 FK 參照；欄位型別可依 DB / EF 映射微調

## 4 Service / Repository 契約範例

- CreateOrderAsync(CreateOrderDto dto) -> OrderId 或 OrderData
- UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion) -> OrderData
- ConfirmOrderAsync(string orderId, string userId) -> 成功 / 錯誤
- CancelOrderAsync(string orderId, string userId, string reason) -> 成功 / 錯誤
- GetOrderAsync(string orderId) -> OrderData
- QueryOrdersAsync(QueryOrderParams p) -> 分頁結果

### DTO 範例（CreateOrderDto）

```json
{

    "OrderId": "string (optional, system can generate)",
    "OperationType": "IN|OUT|TRANSFER|ADJUST|COUNT",
    "SourceLocationId": 123,
    "TargetLocationId": 456,
    "Items": [ { "ItemId": 1, "Quantity": 10, "Unit": "pcs" } ],
    "Reason": "string",
    "CreatedBy": "userId"
}
```

## 5 工作流程（以 Confirm 為核心）

整體序列： Create -> (Update)* -> Confirm -> Inventory adjustment -> Complete

### 5.1 建立（CreateOrder）

- 驗證輸入欄位（OperationType、Items 非空、Quantity > 0、Location 存在）
- 預設 Status = Draft，Version = 1
- 回傳 OrderId

### 5.2 修改（UpdateOrder）

- 僅允許在 Draft 或 Rejected 狀態修改
- 使用 expectedVersion 實作樂觀鎖，版本不符回 409（Conflict）

### 5.3 確認（ConfirmOrder）

- 僅允許 Draft 轉為 Confirmed
- 必須在單一 DB 交易中完成：


- 重新驗證資料（可用庫存、位置有效）
- 調整實際庫存（OUT 減、IN 加、TRANSFER 減/加）
- 新增 InventoryLedger 條目
- 更新 Order 狀態與 Version

- 若驗證失敗（例如庫存不足），需回滾並回傳 422

### 5.4 取消（CancelOrder）

- Draft 可直接取消
- Confirmed 若要取消，需執行補償動作（回補庫存）或依業務規則拒絕取消

### 5.5 完成（CompleteOrder）

- 當下游流程完成後標註 Completed，記錄 CompletedAt

## 6 交易與一致性

- 在 Confirm / Cancel 關鍵路徑使用 DB transaction
- 使用 Version（樂觀鎖）避免 lost update
- 高併發熱點可視情況使用悲觀鎖（SELECT ... FOR UPDATE）或分散式鎖（Redis）
- 庫存量與 ledger 必須原子性更新；跨系統請設計補償型流程（Saga）

## 7 驗證規則

- OperationType 必為允許值
- Items 不可為空；每項 Quantity > 0
- OUT / TRANSFER（來源扣庫）需檢查可用庫存
- IN / TRANSFER（目標增庫）需確認倉別 / 儲位存在
- OrderId 必須唯一

## 8 錯誤處理建議

- 400 BadRequest: 輸入驗證失敗
- 404 NotFound: Item / Location / Order 不存在
- 409 Conflict: 版本衝突或 OrderId 重複
- 422 UnprocessableEntity: 庫存不足或業務驗證失敗
- 500 InternalServerError: 系統例外

錯誤回應應包含: ErrorCode, Message, Details (optional)

## 9 稽核與日誌

- 記錄建立、修改、確認、取消、完成等事件（UserId、Timestamp、Action、Before/After 摘要）
- InventoryLedger 必須可追溯至 OrderId；ledger 建議包含 Change (+/-)、Reason、RefOrderId、CreatedAt、CreatedBy

## 10 確認（Confirm）交易示意（SQL / Pseudocode）

```sql
BEGIN TRANSACTION;

-- 讀取 Order，檢查狀態與版本
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN

    ROLLBACK;
    RAISERROR('Order not in Draft or not found', 16, 1);
    RETURN;
END

-- 針對每個 item 檢查庫存（示意）
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN

    ROLLBACK;
    RAISERROR('Insufficient stock', 16, 1);
    RETURN;
END

-- 扣庫並寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order 狀態與版本（樂觀鎖）
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN

    ROLLBACK;
    RAISERROR('Version conflict', 16, 1);
    RETURN;
END

COMMIT;
```

建議 Index：

- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準（Acceptance Criteria）

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create / Confirm / Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS / ERP 同步，建議使用事件（Event）或 webhook，並設計重試 / 去重機制

## 14 範例 JSON

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量批次匯入應走批次流程以避免即時鎖爭用

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

本文為 StoreHouseStock_OrderData 的操作規格。如需我拆成專用檔或產生 DTO / 測試範例，請告訴我下一步


- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準（Acceptance Criteria）

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create / Confirm / Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS / ERP 同步，建議使用事件（Event）或 webhook，並設計重試 / 去重機制

## 14 範例 JSON

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量批次匯入應走批次流程以避免即時鎖爭用

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

本文為 StoreHouseStock_OrderData 的操作規格。如需我拆成專用檔或產生 DTO / 測試範例，請告訴我下一步
---
title: StoreHouseStock_OrderData 操作規格
version: 1.0
date_created: 2025-11-13
owner: WebStoreHouse Team
tags: [spec, storehouse, orderdata]
---

# StoreHouseStock_OrderData 操作規格

Hi 豬豬 🐽🐽🐷，這份文件定義 StoreHouseStock_OrderData（以下稱 OrderData）的資料契約與操作邏輯，供開發、測試與系統整合使用。
# StoreHouseStock_OrderData 操作規格

Hi 豬豬 🐽🐽🐷，這份文件定義 StoreHouseStock_OrderData（以下稱 OrderData）的資料契約與操作邏輯，供開發、測試與系統整合使用。

## 摘要

- 描述 OrderData 的資料欄位與契約
- 定義 Create / Update / Confirm / Cancel / Complete 的服務契約與交易行為
- 提供 Confirm 的 SQL 範例、JSON 範例、驗收標準與測試策略

## 1 目的與範圍

- 目的：定義倉儲訂單的建立、修改、確認與取消行為，以及一致性保證
- 範圍：資料模型、Service / Repository 介面、交易流程與測試策略

## 2 名詞定義

- OrderData / StoreHouseStock_OrderData：倉儲操作記錄
- OperationType：IN, OUT, TRANSFER, ADJUST, COUNT
- Status：Draft, Confirmed, Completed, Cancelled, Rejected
- OrderId：業務單號（唯一識別）

## 3 建議資料欄位（範例）

- Id (bigint) - 系統主鍵
- OrderId (nvarchar) - 業務單號（唯一）
- OperationType (nvarchar) - 操作類型
- Status (nvarchar) - 訂單狀態
- SourceLocationId (int) - 來源儲位 / 倉別
- TargetLocationId (int) - 目標儲位 / 倉別
- ItemId (int) - 品項識別
- Quantity (decimal) - 數量
- Unit (nvarchar) - 單位（pcs / kg）
- Reason (nvarchar) - 備註或原因
- CreatedBy (nvarchar), CreatedAt (datetime)
- ConfirmedBy (nvarchar), ConfirmedAt (datetime)
- CompletedAt (datetime)
- CancelledBy (nvarchar), CancelledAt (datetime)
- Version (int) - 樂觀鎖版本號

> 註：若系統已有對應表，請以 FK 參照；欄位型別可依 DB / EF 映射微調

## 4 Service / Repository 契約範例

- CreateOrderAsync(CreateOrderDto dto) -> OrderId 或 OrderData
- UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion) -> OrderData
- ConfirmOrderAsync(string orderId, string userId) -> 成功 / 錯誤
- CancelOrderAsync(string orderId, string userId, string reason) -> 成功 / 錯誤
- GetOrderAsync(string orderId) -> OrderData
- QueryOrdersAsync(QueryOrderParams p) -> 分頁結果

### DTO 範例（CreateOrderDto）

```json
{
    "OrderId": "string (optional, system can generate)",
    "OperationType": "IN|OUT|TRANSFER|ADJUST|COUNT",
    "SourceLocationId": 123,
    "TargetLocationId": 456,
    "Items": [ { "ItemId": 1, "Quantity": 10, "Unit": "pcs" } ],
    "Reason": "string",
    "CreatedBy": "userId"
}
```

## 5 工作流程（以 Confirm 為核心）

整體序列： Create -> (Update)* -> Confirm -> Inventory adjustment -> Complete

### 5.1 建立（CreateOrder）

- 驗證輸入欄位（OperationType、Items 非空、Quantity > 0、Location 存在）
- 預設 Status = Draft，Version = 1
- 回傳 OrderId

### 5.2 修改（UpdateOrder）

- 僅允許在 Draft 或 Rejected 狀態修改
- 使用 expectedVersion 實作樂觀鎖，版本不符回 409（Conflict）

### 5.3 確認（ConfirmOrder）

- 僅允許 Draft 轉為 Confirmed
- 必須在單一 DB 交易中完成：

    - 重新驗證資料（可用庫存、位置有效）
    - 調整實際庫存（OUT 減、IN 加、TRANSFER 減/加）
    - 新增 InventoryLedger 條目
    - 更新 Order 狀態與 Version

- 若驗證失敗（例如庫存不足），需回滾並回傳 422

### 5.4 取消（CancelOrder）

- Draft 可直接取消
- Confirmed 若要取消，需執行補償動作（回補庫存）或依業務規則拒絕取消

### 5.5 完成（CompleteOrder）

- 當下游流程完成後標註 Completed，記錄 CompletedAt

## 6 交易與一致性

- 在 Confirm / Cancel 關鍵路徑使用 DB transaction
- 使用 Version（樂觀鎖）避免 lost update
- 高併發熱點可視情況使用悲觀鎖（SELECT ... FOR UPDATE）或分散式鎖（Redis）
- 庫存量與 ledger 必須原子性更新；跨系統請設計補償型流程（Saga）

## 7 驗證規則

- OperationType 必為允許值
- Items 不可為空；每項 Quantity > 0
- OUT / TRANSFER（來源扣庫）需檢查可用庫存
- IN / TRANSFER（目標增庫）需確認倉別 / 儲位存在
- OrderId 必須唯一

## 8 錯誤處理建議

- 400 BadRequest: 輸入驗證失敗
- 404 NotFound: Item / Location / Order 不存在
- 409 Conflict: 版本衝突或 OrderId 重複
- 422 UnprocessableEntity: 庫存不足或業務驗證失敗
- 500 InternalServerError: 系統例外

錯誤回應應包含: ErrorCode, Message, Details (optional)

## 9 稽核與日誌

- 記錄建立、修改、確認、取消、完成等事件（UserId、Timestamp、Action、Before/After 摘要）
- InventoryLedger 必須可追溯至 OrderId；ledger 建議包含 Change (+/-)、Reason、RefOrderId、CreatedAt、CreatedBy

## 10 確認（Confirm）交易示意（SQL / Pseudocode）

```sql
BEGIN TRANSACTION;

-- 讀取 Order，檢查狀態與版本
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN
        ROLLBACK;
        RAISERROR('Order not in Draft or not found', 16, 1);
        RETURN;
END

-- 針對每個 item 檢查庫存（示意）
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN
        ROLLBACK;
        RAISERROR('Insufficient stock', 16, 1);
        RETURN;
END

-- 扣庫並寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order 狀態與版本（樂觀鎖）
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
        ROLLBACK;
        RAISERROR('Version conflict', 16, 1);
        RETURN;
END

COMMIT;
```

建議 Index：

- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準（Acceptance Criteria）

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create / Confirm / Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS / ERP 同步，建議使用事件（Event）或 webhook，並設計重試 / 去重機制

## 14 範例 JSON

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量批次匯入應走批次流程以避免即時鎖爭用

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

本文為 StoreHouseStock_OrderData 的操作規格。如需我拆成專用檔或產生 DTO / 測試範例，請告訴我下一步

-- 讀取 Order，檢查狀態與版本
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN
        ROLLBACK;
        RAISERROR('Order not in Draft or not found', 16, 1);
        RETURN;
END

-- 針對每個 item 檢查庫存（示意）
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN
        ROLLBACK;
        RAISERROR('Insufficient stock', 16, 1);
        RETURN;
END

-- 扣庫並寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order 狀態與版本（樂觀鎖）
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
        ROLLBACK;
        RAISERROR('Version conflict', 16, 1);
        RETURN;
END

COMMIT;
```

建議 Index：

- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create / Confirm / Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS / ERP 同步，建議使用事件（Event）或 webhook，並設計重試 / 去重機制

## 14 範例 JSON

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量批次匯入應走批次流程以避免即時鎖爭用

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

本文為 StoreHouseStock_OrderData 的操作規格。如需我拆成專用檔或產生 DTO / 測試範例，請告訴我下一步


-- 讀取 Order，檢查狀態與版本
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN
    ROLLBACK;
    RAISERROR('Order not in Draft or not found', 16, 1);
    RETURN;
END

-- 針對每個 item 檢查庫存（示意）
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN
    ROLLBACK;
    RAISERROR('Insufficient stock', 16, 1);
    RETURN;
END

-- 扣庫並寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order 狀態與版本（樂觀鎖）
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
    ROLLBACK;
    RAISERROR('Version conflict', 16, 1);
    RETURN;
END

COMMIT;
```

建議 Index：

- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create / Confirm / Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS / ERP 同步，建議使用事件（Event）或 webhook，並設計重試 / 去重機制

## 14 範例 JSON

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量批次匯入應走批次流程以避免即時鎖爭用

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

本文為 StoreHouseStock_OrderData 的操作規格。如需我拆成專用檔或產生 DTO / 測試範例，請告訴我下一步

---

本文為 StoreHouseStock_OrderData 的操作規格。若需要拆成專用檔或由此產生 DTO / 測試範例，請告訴我下一步。

title: StoreHouseStock_OrderData 操作規格
version: 1.0
date_created: 2025-11-13
owner: WebStoreHouse Team
tags: [spec, storehouse, orderdata]
---

# 資料查詢

Hi 豬豬 🐽🐽🐷，這份文件定義 StoreHouseStock_OrderData（以下稱 OrderData）的資料契約與操作邏輯，供開發、測試與系統整合使用。

## 摘要

- 描述 OrderData 的資料欄位與契約
- 定義 Create / Update / Confirm / Cancel / Complete 的服務契約與交易行為
- 提供 Confirm 的 SQL 範例、JSON 範例、驗收標準與測試策略

## 1 目的與範圍

- 目的：定義倉儲訂單（出入庫、調撥、盤點調整等）的建立、修改、確認與取消行為，以及一致性保證
- 範圍：資料模型、Service / Repository 介面契約、交易流程、驗收準則、測試策略與示意 SQL / JSON

## 2 名詞定義

- OrderData / StoreHouseStock_OrderData：倉儲操作記錄
- 在 Confirm / Cancel 關鍵路徑使用 DB transaction
- 使用 Version（樂觀鎖）避免 lost update
- 高併發熱點可視情況使用悲觀鎖（SELECT ... FOR UPDATE）或分散式鎖（Redis）
- 庫存量與 ledger 必須原子性更新；跨系統請設計補償型流程（Saga）
# StoreHouseStock_OrderData 操作規格

Hi 豬豬 🐽🐽🐷，這份文件定義 StoreHouseStock_OrderData（以下稱 OrderData）的資料契約與操作邏輯，供開發、測試與系統整合使用。

## 摘要

- 描述 OrderData 的資料欄位與契約。
- 定義 Create / Update / Confirm / Cancel / Complete 的服務契約與交易行為。
- 提供 Confirm 的 SQL 範例、JSON 範例、驗收標準與測試策略。

## 1 目的與範圍

- 目的：定義倉儲訂單（出入庫、調撥、盤點調整等）的建立、修改、確認與取消行為，以及一致性保證。
- 範圍：資料模型、Service / Repository 介面契約、交易流程、驗收準則與測試策略。

## 2 名詞定義

# 資料查詢 — StoreHouseStock_OrderData 操作規格

Hi 豬豬 🐽🐽🐷

本文為 StoreHouseStock_OrderData（以下簡稱 OrderData）的開發者規格。內容包含資料欄位、Service/Repository 契約、Confirm 交易示意、稽核（ledger）、索引建議、驗收標準與測試策略。

所有段落已使用 ATX 標題；fenced code blocks 標註語言；文件中不含硬 tab（U+0009）。

## 1 目的與範圍

- 目的：提供可直接實作與驗證的 Order 處理契約與交易範例。
- 範圍：Order 建立、修改、確認、取消、完成流程；交易一致性；稽核需求；測試策略。

## 2 名詞定義

- OrderData / StoreHouseStock_OrderData：倉儲訂單資料物件（出入庫、調撥、盤點）。
- OperationType：IN / OUT / TRANSFER / ADJUST / COUNT。
- Status：Draft / Confirmed / Completed / Cancelled / Rejected。

## 3 建議資料欄位（摘要）

- Id (bigint)
- OrderId (string) — 業務單號（唯一）
- OperationType, Status
- SourceLocationId, TargetLocationId
- Items (array of { ItemId, Quantity, Unit })
- Reason, CreatedBy, CreatedAt, ConfirmedBy, ConfirmedAt
- Version (int) — 樂觀鎖

建議額外維護 InventoryLedger：RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt。

## 4 Service / Repository 介面

- CreateOrderAsync(CreateOrderDto) -> OrderId
- UpdateOrderAsync(orderId, UpdateOrderDto, expectedVersion) -> OrderData
- ConfirmOrderAsync(orderId, userId) -> Result
- CancelOrderAsync(orderId, userId, reason) -> Result
- GetOrderAsync(orderId) -> OrderData

錯誤回傳建議：400 / 404 / 409 / 422 / 500。

## 5 Confirm 交易示意（關鍵步驟）

1. 讀取 Order（Status = Draft）並取得 Version。
2. 對每項 Item 檢查來源位置可用庫存；必要時在 Inventory 上使用行鎖（SELECT ... FOR UPDATE）。
3. 更新 Inventory，並同時寫入 InventoryLedger（包含 BalanceAfter）。
4. 使用樂觀鎖更新 Order（Version++ 並 Status='Confirmed'）。
5. Commit；如任一步失敗則 Rollback 並回傳明確錯誤（InsufficientStock / VersionConflict）。

設計要點：交易範圍儘量短，避免在交易內呼叫外部服務；跨系統場景使用 Saga / 補償策略。

### Confirm 範例：SQL / Pseudocode

```sql
BEGIN TRANSACTION;

-- 1. 讀取 Order
SELECT Status, Version FROM StoreHouseStock_OrderData WHERE OrderId = @OrderId;

-- 2. 檢查並鎖定 Inventory
SELECT AvailableQty FROM Inventory WHERE ItemId = @ItemId AND LocationId = @SourceLocationId FOR UPDATE;

-- 3. 更新 Inventory 與 Ledger
UPDATE Inventory SET Quantity = Quantity - @Quantity WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;
INSERT INTO InventoryLedger (RefOrderId, ItemId, LocationId, Change, BalanceAfter, Reason, CreatedBy, CreatedAt)
VALUES (@OrderId, @ItemId, @SourceLocationId, -@Quantity, /*balance*/ 0, @Reason, @User, GETDATE());

-- 4. 樂觀鎖更新 Order
UPDATE StoreHouseStock_OrderData
SET Status='Confirmed', ConfirmedBy=@User, ConfirmedAt=GETDATE(), Version=Version+1
WHERE OrderId=@OrderId AND Version=@ExpectedVersion;

COMMIT;
```

## 6 稽核（InventoryLedger）欄位建議

- Id (bigint)
- RefOrderId (string)
- ItemId (bigint)
- LocationId (int)
- Change (decimal)
- BalanceAfter (decimal)
- Reason (string)
- CreatedBy (string)
- CreatedAt (datetime)

Ledger 必須可重建變動序列以利稽核與對帳。

## 7 索引建議

- IX_Order_OrderId (OrderId) UNIQUE
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

設計要點：避免在熱門索引上執行大量寫入造成冷熱分離問題；對查詢型報表可建立額外覆寫索引。

## 8 驗收標準（Acceptance Criteria）

- AC-001: 建立 Order 並能透過 GetOrder 讀回正確內容。
- AC-002: Confirm 成功時，Inventory 與 InventoryLedger 正確更新（數量與餘額一致）。
- AC-003: 當庫存不足時，Confirm 回滾且回傳 422（不修改 Inventory / Ledger / Order）。
- AC-004: 當 Version 不符時，更新/確認失敗並回傳 409（不修改 Inventory）。
- AC-005: 所有 Confirm 操作均寫入可稽核之 Ledger 條目。

## 9 測試策略（概要）

- 單元測試：Service 層（happy path、InsufficientStock、VersionConflict、input validation）。
- 整合測試：使用測試 DB 執行 Create -> Confirm，驗證 Inventory / InventoryLedger / Order 的一致性。
- 並發測試：模擬多個 concurrent Confirm 呼叫以驗證樂觀鎖或悲觀鎖策略的行為。

## 10 後續建議 artefact

- SQL DDL：Inventory / InventoryLedger / StoreHouseStock_OrderData
- C# DTO + IOrderService 範例
- xUnit integration tests（含並發場景）

若要，我可以建立上述其中一項的範例實作（請指定要產生的 artefact）。


### 5.5 完成（CompleteOrder）

- 當下游流程完成後標註 Completed，記錄 CompletedAt。

## 6 交易與一致性

- 在 Confirm / Cancel 關鍵路徑使用 DB transaction。
- 使用 Version（樂觀鎖）避免 lost update。
- 高併發熱點可視情況使用悲觀鎖（SELECT ... FOR UPDATE）或分散式鎖（Redis）。
- 庫存量與 ledger 必須原子性更新；跨系統請設計補償型流程（Saga）。

## 7 驗證規則

- OperationType 必為允許值。
- Items 不可為空；每項 Quantity > 0。
- OUT / TRANSFER（來源扣庫）需檢查可用庫存。
- IN / TRANSFER（目標增庫）需確認倉別 / 儲位存在。
- OrderId 必須唯一。

## 8 錯誤處理建議（HTTP 對應）

- 400 BadRequest：輸入驗證失敗。
- 404 NotFound：Item / Location / Order 不存在。
- 409 Conflict：版本衝突或 OrderId 重複。
- 422 UnprocessableEntity：庫存不足或業務驗證失敗。
- 500 InternalServerError：系統例外。

錯誤回應應包含： ErrorCode, Message, Details (optional)。

## 9 稽核與日誌

- 記錄建立、修改、確認、取消、完成等事件（UserId、Timestamp、Action、Before/After 摘要）。
- InventoryLedger 必須可追溯至 OrderId；ledger 建議包含 Change (+/-)、Reason、RefOrderId、CreatedAt、CreatedBy。

## 10 確認（Confirm）交易示意（SQL / Pseudocode）

```sql
BEGIN TRANSACTION;

-- 讀取 Order，檢查狀態與版本
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN
    ROLLBACK;
    RAISERROR('Order not in Draft or not found', 16, 1);
    RETURN;
END

-- 針對每個 item 檢查庫存（示意）
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN
    ROLLBACK;
    RAISERROR('Insufficient stock', 16, 1);
    RETURN;
END

-- 扣庫並寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order 狀態與版本（樂觀鎖）
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
    ROLLBACK;
    RAISERROR('Version conflict', 16, 1);
    RETURN;
END

COMMIT;
```

建議 Index：

- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準（Acceptance Criteria）

- AC-001: 建立有效訂單並可透過 GetOrder 讀回。
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed。
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾。
- AC-004: Update 在版本衝突時回傳 409，資料不被修改。
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消。

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）。
- 整合測試：在測試 DB 上執行 Create / Confirm / Cancel，驗證庫存與 ledger 的一致性。
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為。
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目。

建議測試資料：ItemA (qty 100), LocationA, LocationB。

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新。
- 若需與外部 WMS / ERP 同步，建議使用事件（Event）或 webhook，並設計重試 / 去重機制。

## 14 範例 JSON（Create -> Confirm）

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）。

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果。
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制。
- 大量批次匯入應走批次流程以避免即時鎖爭用。

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱。
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用。

---

本文為 StoreHouseStock_OrderData 的操作規格。如需我拆成專用檔或產生 DTO / 測試範例，請告訴我下一步。

- 記錄建立、修改、確認、取消、完成等事件（UserId、Timestamp、Action、Before/After 摘要）
- InventoryLedger 必須可追溯至 OrderId；ledger 建議包含 Change (+/-)、Reason、RefOrderId、CreatedAt、CreatedBy

## 10 確認（Confirm）交易示意（SQL / Pseudocode）

```sql
BEGIN TRANSACTION;

-- 讀取 Order，檢查狀態與版本
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN
    ROLLBACK;
    RAISERROR('Order not in Draft or not found', 16, 1);
    RETURN;
END

-- 針對每個 item 檢查庫存（示意）
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN
    ROLLBACK;
    RAISERROR('Insufficient stock', 16, 1);
    RETURN;
END

-- 扣庫並寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order 狀態與版本（樂觀鎖）
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
    ROLLBACK;
    RAISERROR('Version conflict', 16, 1);
    RETURN;
END

COMMIT;
```

建議 Index：

- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準（Acceptance Criteria）

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create / Confirm / Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS / ERP 同步，建議使用事件（Event）或 webhook，並設計重試 / 去重機制

## 14 範例 JSON（Create -> Confirm）

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量批次匯入應走批次流程以避免即時鎖爭用

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

本文為 StoreHouseStock_OrderData 的操作規格。若需要拆成專用檔或由此產生 DTO / 測試範例，請告訴我下一步。

FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN
    ROLLBACK;
    RAISERROR('Insufficient stock', 16, 1);
    RETURN;
END

-- 扣庫並寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order 狀態與版本（樂觀鎖）
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
    ROLLBACK;
    RAISERROR('Version conflict', 16, 1);
    RETURN;
END

COMMIT;
```

建議 Index：

- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準（Acceptance Criteria）

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create / Confirm / Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS / ERP 同步，建議使用事件（Event）或 webhook，並設計重試 / 去重機制

## 14 範例 JSON（Create -> Confirm）

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量批次匯入應走批次流程以避免即時鎖爭用

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

以上為 `StoreHouseStock_OrderData` 的操作規格。若要我把此內容拆成專用規格檔（例如 `spec-storehouse-orderdata.md`），或建立對應的 DTO / 測試範例程式碼，我可以接續處理。


- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準（Acceptance Criteria）

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create/Confirm/Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS/ERP 同步，建議使用事件（Event）或 webhook，並設計重試/去重機制

## 14 範例 JSON（Create -> Confirm）

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量批次匯入應走批次流程以避免即時鎖爭用

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

以上為 StoreHouseStock_OrderData 的操作規格。如果要我拆成專用規格檔或產生 DTO/測試範例，我可以接續處理。


- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準（Acceptance Criteria）

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create/Confirm/Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS/ERP 同步，建議使用事件（Event）或 webhook，並設計重試/去重機制

## 14 範例 JSON（Create -> Confirm）

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量批次匯入應走批次流程以避免即時鎖爭用

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

以上為 StoreHouseStock_OrderData 的操作規格。若要我把此內容拆成專用規格檔（例如 spec-storehouse-orderdata.md），或建立對應的 DTO/測試範例程式碼，我可以接續處理。


- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11 驗收標準（Acceptance Criteria）

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create/Confirm/Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS/ERP 同步，建議使用事件（Event）或 webhook，並設計重試/去重機制

## 14 範例 JSON（Create -> Confirm）

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15 邊界情況與建議

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須清楚標註並記錄每項處理結果
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量批次匯入應走批次流程以避免即時鎖爭用

## 16 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

以上為 StoreHouseStock_OrderData 的操作規格。若要我把此內容拆成專用規格檔（例如 spec-storehouse-orderdata.md），或建立對應的 DTO/測試範例程式碼，我可以接續處理。
---
title: StoreHouseStock_OrderData 操作規格
version: 1.0
date_created: 2025-11-13
owner: WebStoreHouse Team
tags: [spec, storehouse, orderdata]
---

# 資料查詢

Hi 豬豬 🐽🐽🐷，這份文件定義 StoreHouseStock_OrderData（以下稱 OrderData）的資料契約與操作邏輯，供開發、測試與系統整合使用。

## 摘要

- 描述 OrderData 的資料欄位與契約
- 定義 Create/Update/Confirm/Cancel/Complete 的服務契約與交易行為
- 提供 Confirm 的 SQL 範例、JSON 範例、驗收標準與測試策略

## 1 目的與範圍

- 目的：定義倉儲訂單（出入庫、調撥、盤點調整等）的建立、修改、確認與取消行為，以及一致性保證
- 範圍：資料模型、Service/Repository 介面契約、交易流程、驗收準則、測試策略與示意 SQL/JSON

## 2 定義

- OrderData / StoreHouseStock_OrderData：倉儲操作記錄
- OperationType：IN, OUT, TRANSFER, ADJUST, COUNT
- Status：Draft, Confirmed, Completed, Cancelled, Rejected
- OrderId：業務單號（唯一識別）

## 3 建議資料欄位（範例）

- Id (bigint) — 系統主鍵
- OrderId (nvarchar) — 業務單號（唯一）
- OperationType (nvarchar) — 操作類型
- Status (nvarchar) — 訂單狀態
- SourceLocationId (int) — 來源儲位/倉別
# 資料查詢

Hi 豬豬 🐽🐽🐷，這份文件定義 StoreHouseStock_OrderData（以下稱 OrderData）的資料契約與操作邏輯，供開發、測試與系統整合使用。

## 摘要

- 描述 OrderData 的資料欄位與契約
- 定義 Create/Update/Confirm/Cancel/Complete 的服務契約與交易行為
- 提供 Confirm 的 SQL 範例、JSON 範例、驗收標準與測試策略

## 1 目的與範圍

- 目的：定義倉儲訂單（出入庫、調撥、盤點調整等）的建立、修改、確認與取消行為，以及一致性保證
- 範圍：資料模型、Service/Repository 介面契約、交易流程、驗收準則、測試策略與示意 SQL/JSON

## 2 定義

- OrderData / StoreHouseStock_OrderData：倉儲操作記錄
- OperationType：IN, OUT, TRANSFER, ADJUST, COUNT
- Status：Draft, Confirmed, Completed, Cancelled, Rejected
- OrderId：業務單號（唯一識別）

## 3 建議資料欄位（範例）

- Id (bigint) — 系統主鍵
- OrderId (nvarchar) — 業務單號（唯一）
- OperationType (nvarchar) — 操作類型
- Status (nvarchar) — 訂單狀態
- SourceLocationId (int) — 來源儲位/倉別
- TargetLocationId (int) — 目標儲位/倉別
- ItemId (int) — 品項識別
- Quantity (decimal) — 數量
- Unit (nvarchar) — 單位（pcs/kg）
- Reason (nvarchar) — 備註或原因
- CreatedBy (nvarchar), CreatedAt (datetime)
- ConfirmedBy (nvarchar), ConfirmedAt (datetime)
- CompletedAt (datetime)
- CancelledBy (nvarchar), CancelledAt (datetime)
- Version (int) — 樂觀鎖版本號

> 註：若系統已有對應表，應以 FK 參照；欄位型別可依 DB / EF 映射微調

- 描述 OrderData 的資料契約與建議欄位
- 定義 Create/Update/Confirm/Cancel/Complete 的服務契約與交易行為
- 提供 Confirm 的 SQL 伪碼、範例 JSON、驗收標準與測試策略

## 1. 目的與範圍

- 目的：定義倉儲訂單（出入庫、調撥、盤點調整等）的資料欄位、操作流程與一致性保證
- 範圍：資料模型、Service/Repository 契約、交易流程、驗收準則、測試策略與示意 SQL/JSON（不包含 UI 呈現細節）

## 2. 名詞定義

- OrderData / StoreHouseStock_OrderData：倉儲操作記錄
- OperationType：IN, OUT, TRANSFER, ADJUST, COUNT
- Status：Draft, Confirmed, Completed, Cancelled, Rejected
- OrderId：業務單號（唯一識別）

## 3. 建議資料欄位（範例）

- Id (bigint) — 系統主鍵
- OrderId (nvarchar) — 業務單號（唯一）
- OperationType (nvarchar) — 操作類型
- Status (nvarchar) — 訂單狀態
- SourceLocationId (int) — 來源儲位/倉別
- TargetLocationId (int) — 目標儲位/倉別
- ItemId (int) — 品項識別
- Quantity (decimal) — 數量
- Unit (nvarchar) — 單位（pcs/kg）
- Reason (nvarchar) — 備註或原因
- CreatedBy (nvarchar), CreatedAt (datetime)
- ConfirmedBy (nvarchar), ConfirmedAt (datetime)
- CompletedAt (datetime)
- CancelledBy (nvarchar), CancelledAt (datetime)
- Version (int) — 樂觀鎖版本號

> 註：若系統已有對應表，應以 FK 參照；欄位型別可依 DB / EF 映射微調

## 4. Service / Repository 契約範例

- CreateOrderAsync(CreateOrderDto dto) -> OrderId 或 OrderData
- UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion) -> OrderData
- ConfirmOrderAsync(string orderId, string userId) -> 成功 / 錯誤
- CancelOrderAsync(string orderId, string userId, string reason) -> 成功 / 錯誤
- GetOrderAsync(string orderId) -> OrderData
- QueryOrdersAsync(QueryOrderParams p) -> 分頁結果

### DTO (CreateOrderDto) 範例

```json
{
    "OrderId": "string (optional, system can generate)",
    "OperationType": "IN|OUT|TRANSFER|ADJUST|COUNT",
    "SourceLocationId": 123,
    "TargetLocationId": 456,
    "Items": [ { "ItemId": 1, "Quantity": 10, "Unit": "pcs" } ],
    "Reason": "string",
    "CreatedBy": "userId"
}
```

## 5. 核心工作流程（以 Confirm 為中心）

整體序列： Create -> (Update)* -> Confirm -> (Inventory Adjustment / Accounting) -> Complete

### 建立（CreateOrder）

- 驗證 DTO 欄位（OperationType、Items、Quantity > 0、Location 存在）
- 預設 Status = Draft，Version = 1
- 回傳 OrderId

### 修改（UpdateOrder）

- 僅允許在 Draft 或 Rejected 狀態修改
- 使用 expectedVersion 實作樂觀鎖，版本不符回 409（Conflict）

### 確認（ConfirmOrder）

- 只允許 Draft 轉 Confirmed
- 必須在單一 DB 交易中完成：
    - 重新驗證資料（可用庫存、位置有效）
    - 調整實際庫存（OUT 減、IN 加、TRANSFER 減+加）
    - 新增 InventoryLedger 條目
    - 更新 Order 狀態與 Version
- 若驗證失敗（例如庫存不足），需回滾並回傳 422

### 取消（CancelOrder）

- Draft 可直接取消
- Confirmed 若要取消，需執行補償動作（回補庫存）或依業務拒絕取消

### 完成（CompleteOrder）

- 當下游流程完成後標註 Completed，記錄 CompletedAt

## 6. 交易、一致性與同時性

- 在 Confirm/Cancel 關鍵路徑使用 DB Transaction
- 使用 Version（樂觀鎖）避免 lost update
- 在高併發或熱點品項可使用悲觀鎖（SELECT ... FOR UPDATE）或分散式鎖（Redis）
- 庫存量與 ledger 必須保持原子性更新；跨系統請設計補償型流程（Saga）

## 7. 驗證規則

- OperationType 必為允許值
- Items 不可為空；每項 Quantity > 0
- OUT / TRANSFER（來源扣庫）需檢查可用庫存
- IN / TRANSFER（目標增庫）需確認倉別/儲位存在
- OrderId 必須唯一

## 8. 錯誤處理建議（HTTP 對應）

- 400 BadRequest：輸入驗證失敗
- 404 NotFound：Item/Location/Order 不存在
- 409 Conflict：版本衝突或 OrderId 重複
- 422 UnprocessableEntity：庫存不足或業務驗證錯誤
- 500 InternalServerError：系統例外

錯誤回應應包含： ErrorCode, Message, Details (optional)

## 9. 稽核與日誌

- 記錄建立、修改、確認、取消、完成等事件（UserId、Timestamp、Action、Before/After 摘要）
- InventoryLedger 必須可追溯至 OrderId；ledger 建議包含 Change (+/-)、Reason、RefOrderId、CreatedAt、CreatedBy

## 10. 實作示意：Confirm 的 SQL 伪碼

```sql
BEGIN TRANSACTION;

-- 讀取 Order，檢查狀態與版本
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN
    ROLLBACK;
    RAISERROR('Order not in Draft or not found', 16, 1);
    RETURN;
END

-- 針對每個 item 檢查庫存（示意）
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN
    ROLLBACK;
    RAISERROR('Insufficient stock', 16, 1);
    RETURN;
END

-- 扣庫並寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order 狀態與版本（樂觀鎖）
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
    ROLLBACK;
    RAISERROR('Version conflict', 16, 1);
    RETURN;
END

COMMIT;
```

建議 Index：

- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

## 11. 驗收標準（Acceptance Criteria）

- AC-001: 建立有效訂單並可透過 GetOrder 讀回
- AC-002: Confirm 時若庫存足夠則更新庫存並將狀態標為 Confirmed
- AC-003: Confirm 時若庫存不足則回傳 422，並保持交易回滾
- AC-004: Update 在版本衝突時回傳 409，資料不被修改
- AC-005: Cancel 已 Confirm 訂單時能夠產生補償（回補庫存）或依業務規則拒絕取消

## 12. 測試策略

- 單元測試：驗證 DTO 與 Service 邏輯（Mock repository）
- 整合測試：在測試 DB 上執行 Create/Confirm/Cancel，驗證庫存與 ledger 的一致性
- 併發測試：模擬多個同時 Confirm 呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E：從 API 執行整套流程並驗證稽核日誌與 ledger 條目

建議測試資料：ItemA (qty 100), LocationA, LocationB

## 13. 相依項目與整合

- 需求 Inventory 與 InventoryLedger 表，並支援交易一致性更新
- 若需與外部 WMS/ERP 同步，建議使用事件（Event）或 webhook，並設計重試/去重機制

## 14. 範例 JSON（Create -> Confirm）

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫示意：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳：HTTP 200 + Order 物件（Status = 'Confirmed'）

## 15. 邊界情況與建議

- 若單筆訂單含多品項且其中一品項庫存不足，預設行為為整筆失敗（原子性）；若業務允許部分成功，需明確設計部分成功與稽核
- 跨庫存分片或多 DB 時，須設計補償型交易（Saga）或使用分散式協調機制
- 大量匯入請走批次流程以避免即時鎖爭用

## 16. 改善建議

- Confirm 成功後發出 InventoryChangedEvent 供其他系統訂閱
- 對熱點 item 採用 Redis 快取與分散式鎖以降低 DB 鎖爭用

---

以上為 StoreHouseStock_OrderData 的操作規格。若要我把此內容拆成專用規格檔（例如 spec-storehouse-orderdata.md），或建立對應的 DTO/測試範例程式碼，我可以接續處理。

### 簡介

本文件說明 `StoreHouseStock_OrderData`（以下簡稱 OrderData）在倉儲系統中的資料結構、主要操作、交易流程、驗證規則、錯誤處理、同時性與測試策略。目標是讓開發者、測試者與系統整合方能清楚理解此資料物件的正確行為與邊界條件。

### 1. 目的與範圍

- 目的：描述庫存訂單型別（出入庫／調撥／盤點等）如何被建立、修改、查詢與取消，並定義必要的驗證、交易與一致性要求。
- 範圍：涵蓋資料模型、CRUD 操作、API/Repository 介面契約、序列流程、交易邊界、錯誤代碼、使用情境範例與自動化測試建議。並不包含 UI 呈現細節或非功能性部署設定。

### 2. 定義

- OrderData / StoreHouseStock_OrderData：代表一筆倉儲操作記錄，可能為出庫、入庫、移位、調撥或盤點調整等。
- OperationType：操作類型，enum：IN, OUT, TRANSFER, ADJUST, COUNT
- Status：狀態，enum：Draft, Confirmed, Completed, Cancelled, Rejected
- BusinessKey / OrderId：唯一識別一筆訂單的字串（系統級 UUID 或自訂單號）

### 3. 資料欄位與資料契約（建議欄位）

欄位命名以英文字為主（符合專案偏好），中文註解說明。

- Id (bigint) - 系統流水號／主鍵
- OrderId (nvarchar) - 業務單號（唯一）
- OperationType (nvarchar) - 操作類型：IN/OUT/TRANSFER/ADJUST/COUNT
- Status (nvarchar) - Draft/Confirmed/Completed/Cancelled/Rejected
- SourceLocationId (int) - 來源儲位/倉別（TRANSFER 或 OUT 必要）
- TargetLocationId (int) - 目標儲位/倉別（IN 或 TRANSFER 必要）
- ItemId (int) - 品項識別
- Quantity (decimal) - 數量（可為小數，視商品單位）
- Unit (nvarchar) - 單位（pcs/kg 等）
- Reason (nvarchar) - 備註或原因（調整、盤點原因等）
- CreatedBy (nvarchar) - 建立者
- CreatedAt (datetime) - 建立時間
- ConfirmedBy (nvarchar) - 確認者
- ConfirmedAt (datetime) - 確認時間
- CompletedAt (datetime) - 完成時間
- CancelledBy (nvarchar) - 取消者
- CancelledAt (datetime) - 取消時間
- Version (int) - 樂觀鎖版本號（Concurrency token）

> 註：若系統已有對應的倉儲與品項表，應以 FK 參照；欄位型別可依 DB 與 EF 映射微調。

### 4. 基本操作契約（Repository / Service 層方法範例）

方法命名與輸入輸出契約（簡潔示例）：

- CreateOrderAsync(CreateOrderDto dto) -> 返回 OrderId 或 完整 OrderData
- UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion) -> 返回更新後 OrderData
- ConfirmOrderAsync(string orderId, string userId) -> 將 Draft 變為 Confirmed，進行庫存扣增/回補
- CompleteOrderAsync(string orderId, string userId) -> 確認所有流程已完成（可選）
- CancelOrderAsync(string orderId, string userId, string reason) -> 將狀態標記為 Cancelled
- GetOrderAsync(string orderId) -> 返回 OrderData
- QueryOrdersAsync(QueryOrderParams params) -> 支援分頁與過濾

DTO 範例（CreateOrderDto）：

```json
{
    "OrderId": "string (optional, system can generate)",
    "OperationType": "IN|OUT|TRANSFER|ADJUST|COUNT",
    "SourceLocationId": 123,
    "TargetLocationId": 456,
    "Items": [ { "ItemId": 1, "Quantity": 10, "Unit": "pcs" } ],
    "Reason": "string",
    "CreatedBy": "userId"
}
```

### 5. 工作流程（以 Confirm 為核心）

整體序列： Create -> (Update)* -> Confirm -> (Inventory Adjustment / Accounting) -> Complete

#### 5.1 建立（CreateOrder）

- 驗證輸入欄位（OperationType、Items 非空、數量 > 0、位置存在等）
- 預設 Status = Draft，Version = 1
- 回傳 OrderId

#### 5.2 修改（UpdateOrder）

- 只能修改 Draft 或 Rejected 的訂單（視業務允許）
- 要求傳入 expectedVersion 以支援樂觀鎖，若版本不符回 409（版本衝突）

#### 5.3 確認（ConfirmOrder）

- 只有 Draft 可確認
- 在同一個 DB 交易中：
- 重新驗證各項條件（可用庫存是否足夠、來源與目標位置是否有效）
- 產生 Inventory journal / ledger 條目（可延後寫入，但必須在同一個整合交易邊界內完成或標記等待處理）
- 對庫存做實際扣減/增加（OUT 扣庫、IN 增庫、TRANSFER 同時扣/增）
- 將 Order.Status 設為 Confirmed、ConfirmedBy/ConfirmedAt 填入
- 若庫存不足或其他驗證失敗，操作失敗並回傳錯誤代碼（見錯誤處理）

#### 5.4 完成（CompleteOrder）

- 當所有後續流程（例如物流、財務過帳）完成後，可將狀態標為 Completed，記錄 CompletedAt

#### 5.5 取消（CancelOrder）

- Draft 或 Confirmed 皆可依業務規則取消（若已 Confirmed 且已調整庫存則需反作庫存變更）
- 取消也應是一個交易性操作：若需回補／回滾庫存，應在同一交易或可補償流程中完成

### 6. 交易與同時性（一致性保障）

- 使用資料庫交易（DB Transaction）包住 Confirm/Cancel 的關鍵邏輯。
- 建議使用樂觀鎖（Version 欄位）保護 Update 與 Confirm 操作，避免 lost update。
- 在高併發環境，針對單一品項/儲位的單信息，可視情況採用悲觀鎖（SELECT ... FOR UPDATE / row lock）或使用分散式鎖（如 Redis lock）來保護庫存調整流程。
- 庫存調整應具有原子性：對應的庫存 ledger 與實際庫存量必須同時更新。

### 7. 驗證規則

- OperationType 必須為允許的 enum 值。
- Items 清單不得為空；每個 Item 的 Quantity 必須 > 0。
- 若 OperationType = OUT 或 TRANSFER（從來源扣庫），系統需檢查 SourceLocation 的可用庫存 >= 欲扣數量。
- 若 OperationType = IN 或 TRANSFER（到目標增庫），需確認 TargetLocation 存在且可放置該 Item。
- OrderId 必須唯一。

### 8. 錯誤處理與錯誤代碼建議

- 400 BadRequest：輸入格式錯誤或必要欄位缺失
- 404 NotFound：指定的 Item、Location 或 OrderId 不存在
- 409 Conflict：版本衝突或 OrderId 重複
- 422 UnprocessableEntity：庫存不足或業務驗證失敗
- 500 InternalError：不可預期的系統錯誤

錯誤回傳 payload 應包含： ErrorCode, Message, Details (optional)

### 9. 日誌與稽核需求

- 重要事件需記錄稽核日誌：建立、修改、確認、取消、完成。每筆日誌應含 UserId、Timestamp、Action、Before/After 摘要。
- 庫存 ledger 條目必須可追溯至 OrderId 與操作者。

### 10. 接口實作範例（SQL / Stored Procedure / Pseudocode 範例）

1) 簡化的確認（Confirm）交易流程（伪碼）

```sql
BEGIN TRANSACTION;

-- 讀取 Order，檢查狀態與版本
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN
    ROLLBACK;
    RAISERROR('Order not in Draft or not found', 16, 1);
    RETURN;
END

-- 針對每個 item 檢查庫存（示意）
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN
    ROLLBACK;
    RAISERROR('Insufficient stock', 16, 1);
    RETURN;
END

-- 扣庫與寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order 狀態與版本
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
    ROLLBACK;
    RAISERROR('Version conflict', 16, 1);
    RETURN;
END

COMMIT;
```

2) 建議的 SQL Index：

- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)

### 11. 驗收標準（Acceptance Criteria）

- AC-001: 建立一筆有效的 IN/OUT/TRANSFER 訂單，回傳 OrderId，且資料可由 GetOrder 讀回。
- AC-002: 在 Confirm 操作時，若來源庫存足夠，庫存量必須被正確更新，且 Order.Status 變為 Confirmed。
- AC-003: 當來源庫存不足時，Confirm 操作回傳 422 並且不會修改任何庫存或 Order 狀態（交易回滾）。
- AC-004: Update 操作在版本衝突時回傳 409，並保留原始資料。
- AC-005: Cancel 已 Confirm 的訂單會產生補償調整（回補庫存）或拒絕取消，依業務規則並能被稽核追蹤。

### 12. 測試自動化策略

- 單元測試：
-   驗證 DTO 驗證規則（空值、型別、數值範圍）
-   Service 層邏輯模擬（使用 Mock repository）驗證流程分支
- 整合測試：
-   使用 In-Memory DB 或測試 DB 執行 Create/Confirm/Cancel 流程，驗證庫存與 ledger 的一致性
-   高併發情境測試：模擬多個 Confirm/Update 對同一 Item 的並行呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E 驗證：
-   從 API 層面跑完整的建立->確認->完成情境，並驗證稽核日誌與 ledger 條目

測試資料建議：

- 建立固定測試倉別與品項：ItemA (initial qty 100), LocationA, LocationB
- 測試情境：單一出庫成功、出庫超量失敗、並行出庫造成 1 個成功其餘失敗（驗證版本衝突或庫存不足）

### 13. 相依項目與部署注意事項

- 需確保 Inventory 表與 InventoryLedger 表存在且可被交易一致性更新
- 若與外部系統（WMS / ERP）同步，需設計對外通知機制（事件或 webhook），並處理重試與重入。

### 14. 範例 JSON（Create -> Confirm 流程）

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫（簡化）：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳成功：HTTP 200 + order object (Status='Confirmed')

### 15. 例外與邊界情況

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須明確標註並記錄每筆 item 的處理結果。
- 若系統跨庫存分片或多 DB，須設計補償型交易（Saga）或使用分散式交易協調機制。
- 大量批次資料匯入（Import）應走批次專用流程，不直接走即時 Confirm 標準流程，以避免鎖爭用與效能問題。

### 16. 後續改善建議

- 視需求加入事件發佈（Event）架構：Confirm 成功後發出 InventoryChangedEvent，供其他系統（WMS、ERP、Reporting）訂閱。
- 考慮將庫存熱點 item 採用 Redis 實作快速檢查與分散式鎖，減少 DB 鎖爭用。

---

以上為 `StoreHouseStock_OrderData` 的操作邏輯完整說明。若要我把此內容拆成 `spec` 目錄下的專用規格檔（例如 `spec-storehouse-orderdata.md`），或建立對應的 DTO/測試範例程式碼，我可以接續處理。
# 資料查詢

Hi 豬豬 🐽🐽🐷 早安，接下來我把 `StoreHouseStock_OrderData` 的操作邏輯完整撰寫在此檔案裡。


# StoreHouseStock_OrderData 操作邏輯


## 簡介

本文件說明 `StoreHouseStock_OrderData`（以下簡稱 OrderData）在倉儲系統中的資料結構、主要操作、交易流程、驗證規則、錯誤處理、同時性與測試策略。目標是讓開發者、測試者與系統整合方能清楚理解此資料物件的正確行為與邊界條件。


## 1. 目的與範圍

- 目的：描述庫存訂單型別（出入庫／調撥／盤點等）如何被建立、修改、查詢與取消，並定義必要的驗證、交易與一致性要求。
- 範圍：涵蓋資料模型、CRUD 操作、API/Repository 介面契約、序列流程、交易邊界、錯誤代碼、使用情境範例與自動化測試建議。並不包含 UI 呈現細節或非功能性部署設定。


## 2. 定義

- OrderData / StoreHouseStock_OrderData：代表一筆倉儲操作記錄，可能為出庫、入庫、移位、調撥或盤點調整等。
- OperationType：操作類型，enum：IN, OUT, TRANSFER, ADJUST, COUNT
- Status：狀態，enum：Draft, Confirmed, Completed, Cancelled, Rejected
- BusinessKey / OrderId：唯一識別一筆訂單的字串（系統級 UUID 或自訂單號）


## 3. 資料欄位與資料契約（建議欄位）

欄位命名以英文字為主（符合專案偏好），中文註解說明。

- Id (bigint) - 系統流水號／主鍵
- OrderId (nvarchar) - 業務單號（唯一）
- OperationType (nvarchar) - 操作類型：IN/OUT/TRANSFER/ADJUST/COUNT
- Status (nvarchar) - Draft/Confirmed/Completed/Cancelled/Rejected
- SourceLocationId (int) - 來源儲位/倉別（TRANSFER 或 OUT 可為必要欄位）
- TargetLocationId (int) - 目標儲位/倉別（IN 或 TRANSFER 必要）
- ItemId (int) - 品項識別
- Quantity (decimal) - 數量（可為小數，視商品單位）
- Unit (nvarchar) - 單位（pcs/kg 等）
- Reason (nvarchar) - 備註或原因（調整、盤點原因等）
- CreatedBy (nvarchar) - 建立者
- CreatedAt (datetime) - 建立時間
- ConfirmedBy (nvarchar) - 確認者
- ConfirmedAt (datetime) - 確認時間
- CompletedAt (datetime) - 完成時間
- CancelledBy (nvarchar) - 取消者
- CancelledAt (datetime) - 取消時間
- Version (int) - 樂觀鎖版本號（Concurrency token）

> 註：若系統已有對應的倉儲與品項表，應以 FK 參照；欄位型別可依 DB 與 EF 映射微調。


## 4. 基本操作契約（Repository / Service 層方法範例）

方法命名與輸入輸出契約（簡潔示例）：

- CreateOrderAsync(CreateOrderDto dto) -> 返回 OrderId 或 完整 OrderData
- UpdateOrderAsync(string orderId, UpdateOrderDto dto, int expectedVersion) -> 返回更新後 OrderData
- ConfirmOrderAsync(string orderId, string userId) -> 將 Draft 變為 Confirmed，進行庫存扣增/回補
- CompleteOrderAsync(string orderId, string userId) -> 確認所有流程已完成（可選）
- CancelOrderAsync(string orderId, string userId, string reason) -> 將狀態標記為 Cancelled
- GetOrderAsync(string orderId) -> 返回 OrderData
- QueryOrdersAsync(QueryOrderParams params) -> 支援分頁與過濾


DTO 範例（CreateOrderDto）：

```json
{
    "OrderId": "string (optional, system can generate)",
    "OperationType": "IN|OUT|TRANSFER|ADJUST|COUNT",
    "SourceLocationId": 123,
    "TargetLocationId": 456,
    "Items": [ { "ItemId": 1, "Quantity": 10, "Unit": "pcs" } ],
    "Reason": "string",
    "CreatedBy": "userId"
}
```


## 5. 工作流程（以 Confirm 為核心）

整體序列： Create -> (Update)* -> Confirm -> (Inventory Adjustment / Accounting) -> Complete


### 1. 建立（CreateOrder）

- 驗證輸入欄位（OperationType、Items 非空、數量 > 0、位置存在等）
- 預設 Status = Draft，Version = 1
- 回傳 OrderId


### 2. 修改（UpdateOrder）

- 只能修改 Draft 或 Rejected 的訂單（視業務允許）
- 要求傳入 expectedVersion 以支援樂觀鎖，若版本不符回 409（版本衝突）


### 3. 確認（ConfirmOrder）

- 只有 Draft 可確認
- 在同一個 DB 交易中：
    - 重新驗證各項條件（可用庫存是否足夠、來源與目標位置是否有效）
    - 產生 Inventory journal / ledger 條目（可延後寫入，但必須在同一個整合交易邊界內完成或標記等待處理）
    - 對庫存做實際扣減/增加（OUT 扣庫、IN 增庫、TRANSFER 同時扣/增）
    - 將 Order.Status 設為 Confirmed、ConfirmedBy/ConfirmedAt 填入
- 若庫存不足或其他驗證失敗，操作失敗並回傳錯誤代碼（見錯誤處理）

### 4. 完成（CompleteOrder）

- 當所有後續流程（例如物流、財務過帳）完成後，可將狀態標為 Completed，記錄 CompletedAt

### 5. 取消（CancelOrder）

- Draft 或 Confirmed 皆可依業務規則取消（若已 Confirmed 且已調整庫存則需反作庫存變更）
- 取消也應是一個交易性操作：若需回補／回滾庫存，應在同一交易或可補償流程中完成


## 6. 交易與同時性（一致性保障）

- 使用資料庫交易（DB Transaction）包住 Confirm/Cancel 的關鍵邏輯。
- 建議使用樂觀鎖（Version 欄位）保護 Update 與 Confirm 操作，避免 lost update。
- 在高併發環境，針對單一品項/儲位的單信息，可視情況採用悲觀鎖（SELECT ... FOR UPDATE / row lock）或使用分散式鎖（如 Redis lock）來保護庫存調整流程。
- 庫存調整應具有原子性：對應的庫存 ledger 與實際庫存量必須同時更新。


## 7. 驗證規則

- OperationType 必須為允許的 enum 值。
- Items 清單不得為空；每個 Item 的 Quantity 必須 > 0。
- 若 OperationType = OUT 或 TRANSFER（從來源扣庫），系統需檢查 SourceLocation 的可用庫存 >= 欲扣數量。
- 若 OperationType = IN 或 TRANSFER（到目標增庫），需確認 TargetLocation 存在且可放置該 Item。
- OrderId 必須唯一。


## 8. 錯誤處理與錯誤代碼建議

- 400 BadRequest：輸入格式錯誤或必要欄位缺失
- 404 NotFound：指定的 Item、Location 或 OrderId 不存在
- 409 Conflict：版本衝突或 OrderId 重複
- 422 UnprocessableEntity：庫存不足或業務驗證失敗
- 500 InternalError：不可預期的系統錯誤

錯誤回傳 payload 應包含： ErrorCode, Message, Details (optional)


## 9. 日誌與稽核需求

- 重要事件需記錄稽核日誌：建立、修改、確認、取消、完成。每筆日誌應含 UserId、Timestamp、Action、Before/After 摘要。
- 庫存 ledger 條目必須可追溯至 OrderId 與操作者。


## 10. 接口實作範例（SQL / Stored Procedure / Pseudocode 範例）

1) 簡化的確認（Confirm）交易流程（伪碼）

```sql
BEGIN TRANSACTION;

-- 讀取 Order，檢查狀態與版本
SELECT Status, Version
FROM StoreHouseStock_OrderData
WHERE OrderId = @OrderId;

IF (@@ROWCOUNT = 0 OR @Status != 'Draft')
BEGIN
    ROLLBACK;
    RAISERROR('Order not in Draft or not found', 16, 1);
    RETURN;
END

-- 針對每個 item 檢查庫存（示意）
SELECT AvailableQty
FROM Inventory
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId
FOR UPDATE;

IF (AvailableQty < @Quantity)
BEGIN
    ROLLBACK;
    RAISERROR('Insufficient stock', 16, 1);
    RETURN;
END

-- 扣庫與寫入 ledger
UPDATE Inventory
SET Quantity = Quantity - @Quantity
WHERE ItemId = @ItemId AND LocationId = @SourceLocationId;

INSERT INTO InventoryLedger (ItemId, LocationId, OrderId, Change, CreatedAt)
VALUES (@ItemId, @SourceLocationId, @OrderId, -@Quantity, GETDATE());

-- 更新 Order 狀態與版本
UPDATE StoreHouseStock_OrderData
SET Status = 'Confirmed', ConfirmedBy = @user, ConfirmedAt = GETDATE(), Version = Version + 1
WHERE OrderId = @OrderId AND Version = @expectedVersion;

IF (@@ROWCOUNT = 0)
BEGIN
    ROLLBACK;
    RAISERROR('Version conflict', 16, 1);
    RETURN;
END

COMMIT;
```


2) 建議的 SQL Index：

- IX_Order_OrderId (OrderId)
- IX_Order_Status_CreatedAt (Status, CreatedAt)
- IX_Inventory_Item_Location (ItemId, LocationId)


## 11. 驗收標準（Acceptance Criteria）

- AC-001: 建立一筆有效的 IN/OUT/TRANSFER 訂單，回傳 OrderId，且資料可由 GetOrder 讀回。
- AC-002: 在 Confirm 操作時，若來源庫存足夠，庫存量必須被正確更新，且 Order.Status 變為 Confirmed。
- AC-003: 當來源庫存不足時，Confirm 操作回傳 422 並且不會修改任何庫存或 Order 狀態（交易回滾）。
- AC-004: Update 操作在版本衝突時回傳 409，並保留原始資料。
- AC-005: Cancel 已 Confirm 的訂單會產生補償調整（回補庫存）或拒絕取消，依業務規則並能被稽核追蹤。


## 12. 測試自動化策略

- 單元測試：
    - 驗證 DTO 驗證規則（空值、型別、數值範圍）
    - Service 層邏輯模擬（使用 Mock repository）驗證流程分支
- 整合測試：
    - 使用 In-Memory DB 或測試 DB 執行 Create/Confirm/Cancel 流程，驗證庫存與 ledger 的一致性
    - 高併發情境測試：模擬多個 Confirm/Update 對同一 Item 的並行呼叫，驗證樂觀鎖或悲觀鎖行為
- E2E 驗證：
    - 從 API 層面跑完整的建立->確認->完成情境，並驗證稽核日誌與 ledger 條目

測試資料建議：

- 建立固定測試倉別與品項：ItemA (initial qty 100), LocationA, LocationB
- 測試情境：單一出庫成功、出庫超量失敗、並行出庫造成 1 個成功其餘失敗（驗證版本衝突或庫存不足）


## 13. 相依項目與部署注意事項

- 需確保 Inventory 表與 InventoryLedger 表存在且可被交易一致性更新
- 若與外部系統（WMS / ERP）同步，需設計對外通知機制（事件或 webhook），並處理重試與重入。


## 14. 範例 JSON（Create -> Confirm 流程）

Create 請求範例：

```json
{
    "OperationType": "OUT",
    "SourceLocationId": 1,
    "TargetLocationId": null,
    "Items": [ { "ItemId": 1001, "Quantity": 5, "Unit": "pcs" } ],
    "CreatedBy": "alice"
}
```

Confirm 呼叫（簡化）：

POST /api/orders/{orderId}/confirm
Payload: { "userId": "alice" }

回傳成功：HTTP 200 + order object (Status='Confirmed')


## 15. 例外與邊界情況

- 當一筆訂單包含多個品項，其中某一品項庫存不足：整筆 Confirm 應失敗（原子性），或業務允許部分成功時必須明確標註並記錄每筆 item 的處理結果。
- 若系統跨庫存分片或多 DB，須設計補償型交易（Saga）或使用分散式交易協調機制。
- 大量批次資料匯入（Import）應走批次專用流程，不直接走即時 Confirm 標準流程，以避免鎖爭用與效能問題。


## 16. 後續改善建議

- 視需求加入事件發佈（Event）架構：Confirm 成功後發出 InventoryChangedEvent，供其他系統（WMS、ERP、Reporting）訂閱。
- 考慮將庫存熱點 item 採用 Redis 實作快速檢查與分散式鎖，減少 DB 鎖爭用。


---

以上為 `StoreHouseStock_OrderData` 的操作邏輯完整說明。若要我把此內容拆成 `spec` 目錄下的專用規格檔（例如 `spec-storehouse-orderdata.md`），或建立對應的 DTO/測試範例程式碼，我可以接續處理。


