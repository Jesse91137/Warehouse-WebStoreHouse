
## 每日排程"\\192.168.4.11\33 倉庫備料單\07. 收發組\成倉\成倉SAP_Excel\"把EXCEL檔案-ZRSD13 寫入 E_ZRSD13取得寫入

資料來源: 共享檔案目錄（每日排程會匯入 ZRSD13 的 Excel）	
已銷單庫存-[已銷出貨]作業新增資料到[預設出貨]-E_StoreHouseStock_SC

[確認出貨]-將[預計出貨]明細資料正式轉為訂單，將公司代號為[5]的資料寫入[已銷單庫存]（E_StoreHouseStock_BOS）
-建立當日訂單主檔資料[訂單主檔資料]"E_StoreHouseStock_Order"
-扣除[庫存總表]"E_StoreHouseStock"

---
title: 預計出貨 (StoreHouseStock_SC) 操作規格
version: 1.0
date_created: 2025-11-13
last_updated: 2025-11-13
owner: WebStoreHouse Team
tags: [process, spec, storehouse, order]
---

# Introduction

本文件描述 `FunctionController` 中 `StoreHouseStock_SC`（預計出貨）功能的完整操作邏輯、前置條件、資料介面、驗收準則與測試策略。目標是提供清楚且可自動化測試的規格，方便開發、測試與後續維運。

## 1. Purpose & Scope

- 目的：定義從「購物車/預計出貨明細」產生正式訂單、更新出貨明細、處理已銷單(BOS)、以及扣減成倉庫存的完整流程。
- 範圍：涵蓋 `StoreHouseStock_SC` 的 GET（檢視／列表）與 POST（建立訂單／確認出貨）流程，與相關的資料庫寫入/更新行為（含 tOrder、tOrderDetail、E_StoreHouseStock_Order、E_StoreHouseStock_BOS、E_StoreHouseStock 等）。
- 目標讀者：後端工程師、測試工程師、產品負責人、維運人員。
- 假設：系統使用者已通過驗證；購物車資料已存在資料表中（IsApproved = 'N' 表示尚未確認）。

## 2. Definitions

- 預計出貨（Cart / Pending Shipment）：使用者尚未轉換為正式訂單的購物車明細，資料表具有 `IsApproved` 屬性。
- 訂單主檔（tOrder）：訂單的彙總紀錄（收件資訊、會員、OrderGuid 等）。
- 訂單明細（tOrderDetail / E_StoreHouseStock_Order）：實際每筆要出貨的項目。
- 已銷單庫存（E_StoreHouseStock_BOS）：代表已銷出、須另外管理的庫存紀錄（company_code 特殊處理，例如值=5）。
- 成倉庫存（E_StoreHouseStock）：倉庫現有可供出貨的庫存紀錄。

## 3. Requirements, Constraints & Guidelines

- **REQ-001**: 僅處理 `IsApproved = 'N'` 且 `company_name`（或 company_code）不為空的預計出貨明細。
- **REQ-002**: 建立訂單時必須產生唯一 `OrderGuid` 並寫入訂單主檔與相關明細。
- **REQ-003**: 轉換為正式訂單時，將購物車明細之 `IsApproved` 更新為 `'Y'`，並把 `OrderGuid` 記錄在明細上。
- **REQ-004**: 建立 E_StoreHouseStock_Order，內容須包含來源購物車之所有必要欄位（sno、wono、position、exp_shipquantity、company_code、transportation、box_quantity、sap_mark 等）。
- **REQ-005**: 若 `company_code == 5`（或系統內定義的已銷單公司代碼），需同時建立 E_StoreHouseStock_BOS 紀錄。
- **REQ-006**: 確認出貨後，依照出貨明細扣除成倉庫存（E_StoreHouseStock）；扣帳應依規則（例如 FIFO/序號/儲位優先）執行，並避免負庫存。
- **SEC-001**: 建立/更新資料時應在交易(Transaction)中執行，任何步驟失敗需回滾。
- **GUD-001**: 所有變更應記錄操作人與時間（audit），以便追蹤與回溯。

## 4. Interfaces & Data Contracts

以下列出主要被讀寫的資料表欄位（必要欄位示例）。實務上以資料庫 schema 為準：

- tOrder (Order Master)
	- OrderGuid : string (PK, unique)
	- MemberAccount : string
	- ReceiverName : string
	- ReceiverEmail : string
	- ReceiverAddress : string
	- CreatedAt : datetime
	- CreatedBy : string

- tOrderDetail / E_StoreHouseStock_Order (Order Detail)
	- Id / SNo : int
	- OrderGuid : string (FK -> tOrder)
	- Wono : string
	- EngSr : string
	- Position : string
	- ExpShipQuantity : int
	- BoxQuantity : int
	- Transportation : string
	- SapMark : string
	- CompanyCode / CompanyName : string
	- CreatedAt, CreatedBy

- E_StoreHouseStock_BOS (已銷單庫存)
	- Id : int
	- SourceSno : int (來源購物車/明細 sno)
	- Wono, EngSr, Position
	- Quantity : int
	- CompanyCode : string
	- CreatedAt, CreatedBy

- E_StoreHouseStock (成倉庫存)
	- SerialNo : int
	- Wono : string
	- Position : string
	- Quantity : int
	- BoxQuantity : int
	- Package : string
	- CreatedAt : datetime
	- UpdatedAt : datetime

資料交換範例（伪 JSON）:

```json
{
	"OrderGuid": "...",
	"Receiver": { "Name":"", "Email":"", "Address":"" },
	"Items": [ { "Sno":123, "Wono":"...", "ExpShipQuantity":10, "CompanyCode":"5" } ]
}

## 4.1 操作邏輯（詳細實作步驟）

以下為 `StoreHouseStock_SC` 的詳細操作邏輯，包含 GET（檢視／列表）與 POST（建立訂單／確認出貨）兩條主要路徑，並列出每一步的輸入/輸出、錯誤處理、事務邊界與常見 SQL/程式範例供實作引用。

總體契約（Contract）:
- 輸入（POST）: Receiver 資料 (Name, Email, Address)、操作人員帳號 (CurrentUser)、可選的選項 (e.g., allowPartialShip: bool)
- 輸出: 成功時回傳 OrderGuid、新增明細數、每筆明細處理結果；失敗時回傳錯誤碼、可復原原因與不可變更欄位清單。
- 錯誤模式: 資料驗證失敗、庫存不足、DB 例外、重複送出（idempotency）

A. GET: 列表/檢視流程

1. 接口: GET /StoreHouseStock_SC?page={}&pageSize={}&filter={}
2. 權限: 檢查使用者是否已驗證且有檢視權限
3. 查詢條件: 只列出 IsApproved = 'N' 且 (company_code IS NOT NULL AND company_code != '') 的購物車明細
4. 分頁: 使用 OFFSET/FETCH 或分頁 key（依資料庫/ORM）
5. 回傳內容: 明細清單、每筆可用成倉庫存快照 (aggregate by Wono/Position)、未通過檢查的警示資訊

範例 SQL（簡化）:
```
SELECT c.Sno, c.Wono, c.EngSr, c.Position, c.ExpShipQuantity, c.CompanyCode
FROM CartTable c
WHERE c.IsApproved = 'N' AND ISNULL(c.CompanyCode, '') <> ''
ORDER BY c.CreatedAt DESC
OFFSET @offset ROWS FETCH NEXT @pageSize ROWS ONLY;
```

B. POST: 建立訂單與確認出貨（核心流程）

概觀: 整個處理必須在一個資料庫事務（Transaction）內完成（REQ-SEC-001），確保原子性。流程會檢查可處理明細，建立 tOrder，為每筆明細更新 IsApproved 與 OrderGuid，建立 E_StoreHouseStock_Order、條件性建立 E_StoreHouseStock_BOS，並依序從 E_StoreHouseStock 扣減庫存。

事務邊界: 在 DB TransactionScope 或使用 DB transaction（例如 SQLTransaction / TransactionScope）包住整個流程。只在事務成功時 COMMIT，任何失敗則 ROLLBACK。

步驟詳述:

1) 驗證輸入
 - 驗證 Receiver 欄位、CurrentUser、items exist
 - 若輸入不合法，回 400 並說明欄位錯誤

2) 讀取候選購物車明細
 - 查詢條件: IsApproved='N' AND company_code IS NOT NULL/'' AND Sno IN (items from request) OR 全部未核准項目（視 UI 行為）
 - 若沒有符合的明細，回 422 (無可處理明細)

3) 建立 OrderGuid 並檢查重複（Idempotency）
 - 產生一個 GUID
 - 如支援重入防護，可使用 client-provided idempotency-key 來檢查該 key 是否已存在

4) 開啟 DB Transaction

5) 建立 tOrder 主檔
 - 寫入 Receiver 資訊、MemberAccount（CurrentUser）、OrderGuid、CreatedAt、CreatedBy
 - 若寫入失敗，ROLLBACK 並回 500

6) 逐筆處理每個購物車明細（建議排序: 優先序位/先進先出依專案策略）
 - For each cartItem:
	 a) 重新讀取該購物車明細（SELECT WITH (UPDLOCK, ROWLOCK) WHERE Sno = ? AND IsApproved = 'N'）以避免 race condition
	 b) 驗證 company_code 不為空與其他業務規則
	 c) 檢查成倉庫存：查詢 E_StoreHouseStock，根據扣帳策略（FIFO/儲位優先/序號）計算是否有足夠 Quantity
			 - SQL 範例: SELECT SUM(Quantity) FROM E_StoreHouseStock WHERE Wono = @wono AND Position = @position AND Quantity > 0
	 d) 若庫存不足：依設計選項決策
			 - 策略 1(預設/保守): 中斷整個流程 -> ROLLBACK -> 回傳庫存不足錯誤 (AC-003)
			 - 策略 2(選配): 標示該筆為待補貨並繼續處理其他筆（需額外欄位與後續作業）
	 e) 若 company_code == 5，新增 E_StoreHouseStock_BOS 紀錄（包含 SourceSno, Wono, Quantity, CompanyCode, CreatedBy）
	 f) 建立 E_StoreHouseStock_Order（tOrderDetail）紀錄，寫入 OrderGuid
	 g) 更新購物車明細 IsApproved = 'Y' 並把 OrderGuid 回寫到該筆
	 h) 執行庫存扣減：依扣帳規則消耗 E_StoreHouseStock 的庫存列（使用 UPDATE ... OUTPUT 或分批減用）
			 - 保證不會出現負庫存：在扣帳 SQL 中使用 WHERE Quantity >= amount 或先鎖定行並再檢查
			 - 建議紀錄每一次扣帳的來源 SerialNo/BatchId 以利追蹤

7) 所有明細處理完畢後，寫入 audit log（若需在 DB 層則在同一事務內）

8) 提交 transaction

9) 回傳結果: HTTP 200（或 201）包含 OrderGuid、明細處理結果、任何警示訊息

C. 具體 SQL / 程式範例 (伪碼)

伪碼（C# 風格）:

```csharp
using (var tx = db.BeginTransaction()) {
	var orderGuid = Guid.NewGuid().ToString();
	InsertOrder(orderGuid, receiver, currentUser);

	foreach(var item in cartItems) {
		var cart = SelectCartForUpdate(item.Sno); // SELECT ... FOR UPDATE / WITH (UPDLOCK)
		if(cart == null || cart.IsApproved == 'Y') throw new BusinessException("Invalid cart item");

		var available = SumStock(cart.Wono, cart.Position);
		if(available < cart.ExpShipQuantity) throw new InsufficientStockException(cart.Sno);

		InsertOrderDetail(orderGuid, cart);
		if(cart.CompanyCode == "5") InsertBOS(cart);
		DecrementStock(cart.Wono, cart.Position, cart.ExpShipQuantity);
		UpdateCartApprove(cart.Sno, orderGuid);
	}

	InsertAudit(orderGuid, currentUser);
	tx.Commit();
}
```

D. 並發控制、重入 (Idempotency)、以及鎖定策略

- 鎖定策略：對每筆購物車明細在檢查/更新時使用行鎖或悲觀鎖 (SELECT ... WITH (UPDLOCK, ROWLOCK))，避免兩個並行請求同時將同一筆明細轉單。
- 庫存扣減應對 E_StoreHouseStock 的列使用行鎖，或採樂觀鎖版本欄位 (RowVersion/Timestamp) 加上重試機制。
- 重複送出防護：支援 client 提供 idempotency-key；伺服器可建立 Idempotency 表，若該 key 已處理，直接回傳先前結果而不重複建立。

E. 錯誤處理與回應格式

- 常見錯誤代碼與訊息：
	- 400: 輸入驗證錯誤（missing receiver）
	- 422: 無可處理明細或已被核准
	- 409: 庫存不足或資源衝突（lock failure）
	- 500: 資料庫或未知錯誤
- 當事務內發生錯誤：立即 ROLLBACK，response body 應包含失敗項目清單與建議處理方式

F. Audit 與 Logging

- 每次建立訂單/確認出貨，需在 audit 表記錄：OrderGuid、Operator、操作時間、IP、處理明細數、成功/失敗狀態及錯誤摘要。
- 庫存扣減細節（來源 SerialNo、扣減數量、剩餘數量）建議寫入專門的變動紀錄表以便追蹤與還原（如 E_StoreHouseStock_Change 或 E_StoreHouseStock_Log）。

G. 測試與驗證重點（Implementation-level）

- 單元測試：Service 層模擬 repository，測試每個步驟的分支（庫存足夠、不足、company_code=5、部分明細為已核准）。
- Integration 測試：使用測試 DB 或 TransactionScope 回滾，覆蓋整個 POST 流程包含成功與失敗案例。
- 壓力/並發測試：模擬多個同時轉單請求，驗證鎖定策略與重試機制的正確性。

H. 其他注意事項

- 若系統需支援跨倉或多儲位扣帳，實作時需在查詢與扣帳時考慮優先序（例如以儲位、到期日或序號排序）。
- 若採用部分出貨策略（allowPartialShip），在同一 transaction 需將可出貨部分先處理並把無法出貨的部分標示為待補貨或建立 backorder。

```

## 5. Acceptance Criteria

- **AC-001**: Given 有 3 筆購物車明細(IsApproved='N') 且 company_code 不為空，When 執行 POST 建立訂單，Then tOrder 與對應 3 筆 tOrderDetail（E_StoreHouseStock_Order）與每筆明細的 IsApproved 變為 'Y' 且含 OrderGuid。
- **AC-002**: Given 明細中有 company_code=5 的項目，When 建立訂單，Then 對應的 E_StoreHouseStock_BOS 會新增對應紀錄。
- **AC-003**: Given 出貨明細需扣庫存且成倉庫存數量足夠，When 訂單建立，Then 對應 E_StoreHouseStock 中數量被正確扣減且不會出現負數。
- **AC-004**: Given 任一寫入失敗（DB exception），When 建立訂單，Then 資料庫處於事前狀態（所有變更回滾）。
- **AC-005**: Given company_code 為空或該筆明細已被標記為 IsApproved='Y'，When 嘗試轉單，Then 該筆不會被轉為正式訂單，且系統會在回應中保留錯誤/警示訊息供前端顯示。

## 6. Test Automation Strategy

- Test Levels: Unit tests (商業邏輯), Integration tests (資料庫 transaction 與 CRUD), End-to-End（選配）。
- Frameworks: 對於 .NET Framework / MVC 專案，建議使用 xUnit 或 NUnit + Moq 做 Service 層測試；使用本地測試 DB 或交易回滾的 Integration 測試（可使用 TransactionScope 或測試專用 DB）。
- Test Cases 要點：
	- 單筆購物車成功建立訂單且庫存扣減。
	- 包含 company_code=5 的明細會導致 BOS 紀錄建立。
	- 資料庫錯誤時全部回滾。
	- 不足庫存的情況：建立訂單前應阻擋或標記錯誤。
- CI/CD Integration：在 GitHub Actions 中加入 Integration 測試步驟，測試期間使用 ephemeral 測試 DB 或容器化 DB，驗證交易與回滾行為。

## 7. Rationale & Context

- 將購物車狀態從暫定轉為正式訂單是關鍵業務流程，須保證原子性（atomicity）以避免肢解狀態（部分更新）。因此在 DB 層使用 Transaction 並做好 error handling 與 logging 是必要的。
- 已銷單 (BOS) 的獨立寫入，是因為某些公司代號（例如 5）代表需另外建立已銷單庫存紀錄供後續帳務或出貨追蹤使用。

## 8. Dependencies & External Integrations

### External Systems
- **EXT-001**: 共享檔案目錄（每日排程會匯入 ZRSD13 的 Excel），用於補資料或批次處理（僅列為資訊來源）。

### Infrastructure Dependencies
- **INF-001**: 資料庫 (MS SQL) - 支援交易與儲存程序執行。

### Compliance Dependencies
- **COM-001**: 個人資料（收件人資訊）必須符合資料保護原則，郵件與地址等敏感資訊應妥善存取控管與日誌審計。

## 9. Examples & Edge Cases

範例流程（Step-by-step）:

1. 使用者（已登入）開啟 `StoreHouseStock_SC` 頁面 (GET)，系統列出分頁的預計出貨明細。
2. 使用者在確認收件資訊後按確認送出（POST）：帶入 `fReceiver, fEmail, fAddress`。
3. 後端建立唯一 `OrderGuid`。
4. 在 Transaction 範圍中：
	 - 建立 tOrder 主檔（寫入收件人、會員、OrderGuid）。
	 - 查詢購物車明細：條件 `IsApproved = 'N'` 且 `company_name/ company_code != null/''`。
	 - 對每筆明細：
		 a. 更新該筆購物車 `IsApproved = 'Y'` 並填入 `OrderGuid`。
		 b. 建立 E_StoreHouseStock_Order 對應明細。
		 c. 若 `company_code == 5`，則新增 E_StoreHouseStock_BOS 之紀錄。
		 d. 依據明細的 `ExpShipQuantity` 與庫存查詢結果，對 E_StoreHouseStock 執行扣帳（減少 Quantity）。若某筆明細庫存不足，則：
				- 中斷 Transaction，回滾並回傳錯誤訊息；或
				- （可選）標示該筆為待補貨並跳過（依專案決策）。
5. 提交 Transaction，並在前端導向訂單列表頁面（OrderList）。

Edge Cases：
- 部分庫存不足：應定義策略（完全回滾 vs 部分處理 + 人工作業）。
- 已有人先一步取走庫存（並發衝突）：採悲觀鎖或重新查庫邏輯以防 race condition。
- 重複送出（double submit）：以 `OrderGuid` 唯一性與檢查 IsApproved 防止重複建立。

## 10. Validation Criteria

- 所有建立/變更操作在測試 DB 上通過 Integration 測試（含 rollback case）。
- 以模擬使用者流程驗證：不少於 5 個真實場景（含 company_code=5、部分庫存不足、無公司代碼）以驗證系統反應。
- 日誌應能顯示每次訂單建立行為之操作人、OrderGuid、時間與產生之明細數量。

## 11. Related Specifications / Further Reading

- 相關檔案：`spec/庫存處理.md`（若存在 - 建議建立）
- 產品端 UI 規格：`docs/OrderFlow.md`（如有）
- 資料庫 schema 文件：`database/schema.md`

---

**備註**: 本文件為規格草案，若需變更「部分扣帳策略（回滾或部分允許）」請在設計階段決定並更新 REQ 與 Acceptance Criteria。

